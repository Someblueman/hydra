#!/bin/sh
# Hydra - POSIX-compliant CLI for managing parallel AI coding sessions
# Wraps tmux â‰¥ 3.0 and git worktree

set -eu

# Global variables
# Ensure HOME is set to actual user home directory
if [ -z "${HOME:-}" ] || [ ! -d "${HOME:-}" ]; then
    HOME="$(cd ~ && pwd)"
fi
HYDRA_HOME="${HYDRA_HOME:-$HOME/.hydra}"
HYDRA_MAP="$HYDRA_HOME/map"
HYDRA_VERSION="1.4.0"

# Source helper libraries
# Enhanced library detection with multiple fallback paths
# Try to resolve the real path of the hydra binary
HYDRA_BIN_PATH="$0"
if [ -L "$HYDRA_BIN_PATH" ]; then
    # Follow symlinks if possible (POSIX-compliant approach)
    if command -v readlink >/dev/null 2>&1; then
        # Try GNU readlink -f first, then BSD readlink
        HYDRA_BIN_PATH="$(readlink -f "$HYDRA_BIN_PATH" 2>/dev/null || readlink "$HYDRA_BIN_PATH" 2>/dev/null || echo "$HYDRA_BIN_PATH")"
    fi
fi

# Get the directory containing the hydra binary
if HYDRA_BIN_DIR="$(cd "$(dirname "$HYDRA_BIN_PATH")" 2>/dev/null && pwd)"; then
    : # Successfully got absolute path
else
    # Fallback to dirname if cd fails
    HYDRA_BIN_DIR="$(dirname "$HYDRA_BIN_PATH")"
fi

# Try multiple paths to find the library directory
if [ -d "$HYDRA_BIN_DIR/../lib" ] && [ -f "$HYDRA_BIN_DIR/../lib/git.sh" ]; then
    # Running from source - resolve to absolute path
    HYDRA_LIB_DIR="$(cd "$HYDRA_BIN_DIR/../lib" && pwd)"
elif [ -d "/usr/local/lib/hydra" ] && [ -f "/usr/local/lib/hydra/git.sh" ]; then
    # Installed location
    HYDRA_LIB_DIR="/usr/local/lib/hydra"
elif [ -n "${HYDRA_ROOT:-}" ] && [ -d "$HYDRA_ROOT/lib" ] && [ -f "$HYDRA_ROOT/lib/git.sh" ]; then
    # Environment variable override
    HYDRA_LIB_DIR="$HYDRA_ROOT/lib"
else
    echo "Error: Cannot find hydra library directory" >&2
    echo "Searched in:" >&2
    echo "  - $HYDRA_BIN_DIR/../lib (source)" >&2
    echo "  - /usr/local/lib/hydra (installed)" >&2
    [ -n "${HYDRA_ROOT:-}" ] && echo "  - $HYDRA_ROOT/lib (HYDRA_ROOT)" >&2
    echo "" >&2
    echo "Please ensure hydra is properly installed or set HYDRA_ROOT environment variable" >&2
    exit 1
fi

# Lazy library loading - track which libs are loaded
_LOADED_LIBS=""

# Load a library if not already loaded
# Usage: _load_lib <libname>
_load_lib() {
    _lib="$1"
    # Check if already loaded (simple substring check)
    case "$_LOADED_LIBS" in
        *":$_lib:"*) return 0 ;;
    esac
    # shellcheck disable=SC1090
    . "$HYDRA_LIB_DIR/${_lib}.sh"
    _LOADED_LIBS="${_LOADED_LIBS}:${_lib}:"
}

# Load libraries required for a command
# Usage: _load_libs_for_cmd <command>
_load_libs_for_cmd() {
    case "$1" in
        version|help|-v|--version|-h|--help)
            # No libraries needed
            ;;
        list)
            _load_lib output
            _load_lib state
            _load_lib tmux
            ;;
        switch)
            _load_lib state
            _load_lib tmux
            ;;
        group)
            _load_lib output
            _load_lib state
            _load_lib tmux
            ;;
        send|recv)
            _load_lib output
            _load_lib state
            _load_lib tmux
            _load_lib locks
            _load_lib messages
            ;;
        pr)
            _load_lib state
            _load_lib github
            ;;
        tail|broadcast|wait-idle)
            _load_lib state
            _load_lib tmux
            ;;
        kill)
            _load_lib output
            _load_lib paths
            _load_lib locks
            _load_lib git
            _load_lib tmux
            _load_lib state
            _load_lib kill
            ;;
        spawn)
            _load_lib output
            _load_lib paths
            _load_lib locks
            _load_lib git
            _load_lib tmux
            _load_lib layout
            _load_lib state
            _load_lib hooks
            _load_lib yaml
            _load_lib spawn
            _load_lib github
            ;;
        regenerate)
            _load_lib output
            _load_lib paths
            _load_lib locks
            _load_lib git
            _load_lib tmux
            _load_lib layout
            _load_lib state
            _load_lib hooks
            _load_lib yaml
            _load_lib spawn
            ;;
        status)
            _load_lib output
            _load_lib state
            _load_lib tmux
            _load_lib git
            ;;
        doctor|cleanup)
            _load_lib tmux
            _load_lib state
            _load_lib git
            _load_lib locks
            _load_lib output
            ;;
        dashboard|dashboard-exit)
            _load_lib state
            _load_lib tmux
            _load_lib dashboard
            ;;
        tui)
            _load_lib output
            _load_lib paths
            _load_lib locks
            _load_lib git
            _load_lib tmux
            _load_lib layout
            _load_lib state
            _load_lib hooks
            _load_lib yaml
            _load_lib spawn
            _load_lib kill
            _load_lib tui
            ;;
        cycle-layout)
            _load_lib tmux
            _load_lib layout
            ;;
        completion)
            _load_lib completion
            ;;
        *)
            # Unknown command - load all for safety
            _load_lib output
            _load_lib paths
            _load_lib locks
            _load_lib git
            _load_lib tmux
            _load_lib layout
            _load_lib state
            _load_lib completion
            _load_lib dashboard
            _load_lib github
            _load_lib hooks
            _load_lib yaml
            _load_lib spawn
            _load_lib kill
            _load_lib tui
            ;;
    esac
}

# Export paths for downstream helpers (e.g., safe tmux run-shell bindings)
export HYDRA_LIB_DIR
# Resolve the absolute path to the current hydra binary for secure bindings
HYDRA_BIN_CMD="${HYDRA_BIN_PATH}"
export HYDRA_BIN_CMD

# Initialize Hydra home directory
init_hydra_home() {
    if [ ! -d "$HYDRA_HOME" ]; then
        mkdir -p "$HYDRA_HOME"
    fi
    if [ ! -f "$HYDRA_MAP" ]; then
        touch "$HYDRA_MAP"
    fi
}

# Display usage information
usage() {
    cat <<EOF
hydra - Manage parallel AI coding sessions with tmux and git worktree

Usage: hydra <command> [options]

Commands:
  spawn <branch>    Create a new worktree and tmux session
                    Options:
                      -l, --layout <layout>    Apply tmux layout
                      -n, --count <number>     Spawn multiple sessions (1-10)
                      --ai <tool>              Specify AI tool (claude, aider, gemini, etc.)
                      --agents <spec>          Mixed agents (e.g., "claude:2,aider:1")
                      -g, --group <name>       Assign to a group for bulk operations
                      --after <deps>           Wait for sessions to complete (e.g., "branch1,branch2")
                      --pr-new                 Create a draft PR after spawning
  spawn --issue <#> Create a head from a GitHub issue
  spawn --pr <#>    Create a head from an existing GitHub PR
  list              List all active Hydra heads
                    Options:
                      -g, --group <name>       Filter by group
                      --groups                 List all groups with session counts
                      -j, --json               Output in JSON format
                      --deps                   Show dependency tree
  switch            Switch to a different head (interactive)
  kill <branch>     Remove a worktree and its tmux session
  kill --all        Kill all hydra sessions
  kill --group <n>  Kill all sessions in a group
                    Options:
                      --force          Skip confirmation prompt
  group <branch>    Show or set group for a session
                    Usage:
                      group <branch>           Show current group
                      group <branch> <name>    Set group
                      group <branch> --clear   Remove from group
                      group create <name> <branch> [branch...]
                                               Create group with sessions
                      group wait <name>        Wait for group to complete
                      group status <name>      Show group health status
                    Options for subcommands:
                      -t, --timeout <N>        Wait timeout in seconds
                      -j, --json               JSON output for status
  send <branch> <msg> Queue a message to another session's inbox
  recv              Read and clear messages for current session
                    Options:
                      --peek                   Don't remove messages
                      -j, --json               Output in JSON format
  pr [<branch>]     Create or show GitHub PR for a session
                    If no branch specified, uses current session
  tail <branch>     View output from a session
                    Options:
                      -n, --lines <N>          Number of lines (default: 50)
                      -f, --follow             Continuously watch output
  broadcast         Send a command to multiple sessions
                    Options:
                      -g, --group <name>       Target specific group
  wait-idle         Wait for sessions to become idle
                    Options:
                      -g, --group <name>       Wait for specific group
                      -s, --seconds <N>        Idle threshold (default: 10)
                      -t, --timeout <N>        Max wait time (default: 300)
  regenerate        Restore tmux sessions for existing worktrees
  status            Show health status of all heads
                    Options:
                      -j, --json               Output in JSON format
  doctor            Check system health and consistency
  cleanup           Remove dead mappings, stale locks, and orphaned worktrees
  dashboard         View all sessions in a single dashboard
                    Options:
                      -p, --panes-per-session <N|all>  Collect multiple panes per session
  tui               Interactive terminal UI for managing sessions
  cycle-layout      Cycle through tmux pane layouts
  completion        Generate shell completion scripts
  version           Show version information

Options:
  -h, --help        Show this help message

Examples:
  hydra spawn feature-x                    # Create single session
  hydra spawn feature-x -n 3               # Create 3 sessions (feature-x-1, feature-x-2, feature-x-3)
  hydra spawn feature-x -n 3 --ai aider    # Create 3 sessions with aider
  hydra spawn feature-x --ai gemini        # Create session with Google Gemini CLI
  hydra spawn exp --agents "claude:2,aider:1"  # Create 2 claude + 1 aider sessions
  hydra spawn --issue 42                   # Create session from GitHub issue #42
  hydra spawn feature-x -g project-a       # Create session in group 'project-a'
  hydra list --groups                      # Show all groups
  hydra list -g project-a                  # List sessions in group 'project-a'
  hydra group feature-x project-a          # Assign feature-x to group 'project-a'
  hydra tail feature-x                     # View last 50 lines of output
  hydra tail feature-x -f                  # Follow output in real-time
  hydra broadcast "git status"             # Send command to all sessions
  hydra broadcast -g project-a "make test" # Send command to group
  hydra wait-idle -g project-a             # Wait for group to finish
  hydra kill feature-x                     # Kill a specific session
  hydra kill --all                         # Kill all sessions (with confirmation)
  hydra kill --all --force                 # Kill all sessions without confirmation
  hydra kill -g project-a                  # Kill all sessions in group 'project-a'

Environment:
  HYDRA_HOME        Directory for runtime files (default: ~/.hydra)
  HYDRA_AI_COMMAND  Default AI tool (default: claude)
  HYDRA_ROOT        Override hydra installation path (for library discovery)
  HYDRA_DASHBOARD_PANES_PER_SESSION  Panes per session for dashboard (1, N, or all)
EOF
}

# Main command dispatcher
main() {
    init_hydra_home

    # Load only the libraries needed for this command
    _load_libs_for_cmd "${1:-}"

    case "${1:-}" in
        spawn)
            shift
            cmd_spawn "$@"
            ;;
        list)
            shift
            cmd_list "$@"
            ;;
        switch)
            shift
            cmd_switch "$@"
            ;;
        kill)
            shift
            cmd_kill "$@"
            ;;
        group)
            shift
            cmd_group "$@"
            ;;
        send)
            shift
            cmd_send "$@"
            ;;
        recv)
            shift
            cmd_recv "$@"
            ;;
        pr)
            shift
            cmd_pr "$@"
            ;;
        tail)
            shift
            cmd_tail "$@"
            ;;
        broadcast)
            shift
            cmd_broadcast "$@"
            ;;
        wait-idle)
            shift
            cmd_wait_idle "$@"
            ;;
        regenerate)
            shift
            cmd_regenerate "$@"
            ;;
        status)
            shift
            cmd_status "$@"
            ;;
        doctor)
            shift
            cmd_doctor "$@"
            ;;
        cleanup)
            shift
            cmd_cleanup "$@"
            ;;
        dashboard)
            shift
            cmd_dashboard "$@"
            ;;
        dashboard-exit)
            shift
            cmd_dashboard_exit "$@"
            ;;
        tui)
            shift
            cmd_tui "$@"
            ;;
        cycle-layout)
            shift
            cmd_cycle_layout "$@"
            ;;
        completion)
            shift
            cmd_completion "$@"
            ;;
        version|-v|--version)
            echo "Hydra version $HYDRA_VERSION"
            ;;
        help|-h|--help)
            usage
            ;;
        *)
            if [ -z "${1:-}" ]; then
                usage
            else
                echo "Error: Unknown command '$1'" >&2
                echo "Run 'hydra help' for usage information" >&2
                exit 1
            fi
            ;;
    esac
}

# Command implementations
cmd_spawn() {
    # Parse arguments
    branch=""
    layout="default"
    count=1
    ai_tool=""
    agents_spec=""
    issue_num=""
    group=""
    after_deps=""
    pr_num=""
    pr_new=""

    while [ $# -gt 0 ]; do
        case "$1" in
            -l|--layout)
                shift
                layout="$1"
                shift
                ;;
            -n|--count)
                shift
                count="$1"
                shift
                ;;
            --ai)
                shift
                ai_tool="$1"
                shift
                ;;
            --agents)
                shift
                agents_spec="$1"
                shift
                ;;
            -i|--issue)
                shift
                issue_num="$1"
                shift
                ;;
            -g|--group)
                shift
                group="$1"
                shift
                ;;
            --after)
                shift
                after_deps="$1"
                shift
                ;;
            --pr)
                shift
                pr_num="$1"
                shift
                ;;
            --pr-new)
                pr_new="1"
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: hydra spawn <branch> [-l|--layout <layout>] [-n|--count <number>] [--ai <tool>] [--agents <spec>] [-g|--group <name>] [--after <deps>]" >&2
                echo "       hydra spawn --issue <number> [-l|--layout <layout>] [-g|--group <name>]" >&2
                echo "       hydra spawn --pr <number> [-l|--layout <layout>] [-g|--group <name>]" >&2
                exit 1
                ;;
            *)
                if [ -z "$branch" ]; then
                    branch="$1"
                else
                    echo "Error: Too many arguments" >&2
                    echo "Usage: hydra spawn <branch> [-l|--layout <layout>] [-n|--count <number>] [--ai <tool>] [--agents <spec>] [-g|--group <name>] [--after <deps>]" >&2
                    echo "       hydra spawn --issue <number> [-l|--layout <layout>] [-g|--group <name>]" >&2
                    echo "       hydra spawn --pr <number> [-l|--layout <layout>] [-g|--group <name>]" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done
    
    # Handle GitHub issue mode
    if [ -n "$issue_num" ]; then
        if [ -n "$branch" ]; then
            echo "Error: Cannot specify both branch name and issue number" >&2
            exit 1
        fi

        # Check for incompatible options
        if [ "$count" -gt 1 ] || [ -n "$agents_spec" ]; then
            echo "Error: Cannot use bulk spawn options with --issue" >&2
            exit 1
        fi

        if [ -n "$pr_num" ]; then
            echo "Error: Cannot specify both --issue and --pr" >&2
            exit 1
        fi

        # Generate branch from issue
        branch="$(spawn_from_issue "$issue_num")" || exit 1
    fi

    # Handle GitHub PR mode
    if [ -n "$pr_num" ]; then
        if [ -n "$branch" ]; then
            echo "Error: Cannot specify both branch name and --pr" >&2
            exit 1
        fi

        # Check for incompatible options
        if [ "$count" -gt 1 ] || [ -n "$agents_spec" ]; then
            echo "Error: Cannot use bulk spawn options with --pr" >&2
            exit 1
        fi

        # Get branch from PR
        require github
        branch="$(spawn_from_pr "$pr_num")" || exit 1
    fi

    if [ -z "$branch" ]; then
        echo "Error: Branch name is required" >&2
        echo "Usage: hydra spawn <branch> [-l|--layout <layout>] [-n|--count <number>] [--ai <tool>] [--agents <spec>] [-g|--group <name>]" >&2
        echo "       hydra spawn --issue <number> [-l|--layout <layout>] [-g|--group <name>]" >&2
        echo "       hydra spawn --pr <number> [-l|--layout <layout>] [-g|--group <name>]" >&2
        exit 1
    fi
    
    # Validate count
    if ! echo "$count" | grep -q '^[0-9]\+$' || [ "$count" -lt 1 ] || [ "$count" -gt 10 ]; then
        echo "Error: Count must be a number between 1 and 10" >&2
        exit 1
    fi

    # Validate layout early to avoid injection in apply step
    case "$layout" in
        default|dev|full) ;;
        *)
            echo "Error: Invalid layout '$layout' (allowed: default, dev, full)" >&2
            exit 1
            ;;
    esac
    
    # Handle mutually exclusive options
    if [ -n "$agents_spec" ] && [ -n "$ai_tool" ]; then
        echo "Error: Cannot use both --ai and --agents options" >&2
        exit 1
    fi

    # Validate --after (dependencies) if specified
    if [ -n "$after_deps" ]; then
        # Can't use --after with bulk spawn
        if [ "$count" -gt 1 ] || [ -n "$agents_spec" ]; then
            echo "Error: Cannot use --after with bulk spawn options" >&2
            exit 1
        fi

        # Load deps library and validate
        require deps
        if ! validate_deps_spec "$after_deps"; then
            exit 1
        fi

        # Check for circular dependencies
        if ! check_circular_deps "$branch" "$after_deps"; then
            exit 1
        fi
    fi

    # If agents spec is provided, delegate to bulk spawn with mixed agents
    if [ -n "$agents_spec" ]; then
        spawn_bulk_mixed "$branch" "$agents_spec" "$layout" "$group"
        return $?
    fi

    # If count > 1, delegate to bulk spawn
    if [ "$count" -gt 1 ]; then
        spawn_bulk "$branch" "$count" "$layout" "$ai_tool" "$group"
        return $?
    fi

    # Single spawn - use helper function
    # Pass pr_num if spawning from PR (to store in state)
    spawn_pr_num=""
    if [ -n "$pr_num" ]; then
        spawn_pr_num="$pr_num"
    fi

    if session="$(spawn_single "$branch" "$layout" "$ai_tool" "$group" "$after_deps" "$spawn_pr_num")"; then
        # Handle --pr-new: create a draft PR after spawn
        if [ -n "$pr_new" ]; then
            require github
            echo "Creating draft PR for branch '$branch'..." >&2
            new_pr="$(create_pr_for_branch "$branch" --draft 2>&1)" || {
                echo "Warning: Failed to create PR: $new_pr" >&2
            }
            if [ -n "$new_pr" ] && echo "$new_pr" | grep -q '^[0-9]*$'; then
                set_pr_for_branch "$branch" "$new_pr"
                echo "Created draft PR #$new_pr" >&2
            fi
        fi

        # Optionally skip switching (useful for demos/automation)
        if [ -n "${HYDRA_NO_SWITCH:-}" ]; then
            echo "Session '$session' created (HYDRA_NO_SWITCH set; not attaching)"
        else
            # Switch to the new session (only in terminal)
            if [ -t 0 ] && [ -t 1 ]; then
                echo "Switching to session '$session'..."
                switch_to_session "$session"
            else
                echo "Session '$session' created successfully (not switching - not in terminal)"
            fi
        fi
        return 0
    else
        return 1
    fi
}

cmd_list() {
    # Parse arguments
    filter_group=""
    show_groups=""
    json_output=""
    show_deps=""
    while [ $# -gt 0 ]; do
        case "$1" in
            -g|--group)
                shift
                filter_group="$1"
                shift
                ;;
            --groups)
                show_groups="1"
                shift
                ;;
            -j|--json)
                json_output="1"
                shift
                ;;
            --deps)
                show_deps="1"
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: hydra list [-g|--group <name>] [--groups] [--json] [--deps]" >&2
                exit 1
                ;;
            *)
                echo "Error: Unexpected argument '$1'" >&2
                exit 1
                ;;
        esac
    done

    # Show dependency tree if requested
    if [ -n "$show_deps" ]; then
        require deps
        echo "Session Dependencies:"
        echo ""
        build_full_dep_tree
        return 0
    fi

    # List all groups if requested
    if [ -n "$show_groups" ]; then
        groups="$(list_groups)"
        if [ -n "$json_output" ]; then
            # JSON output for groups - collect in temp file to avoid subshell issue
            tmpjson="$(mktemp)"
            trap 'rm -f "$tmpjson"' EXIT
            echo "$groups" | while read -r g; do
                [ -z "$g" ] && continue
                count="$(list_mappings_for_group "$g" | wc -l | tr -d ' ')"
                printf '{"name": "%s", "count": %s}\n' "$(json_escape "$g")" "$count" >> "$tmpjson"
            done
            printf '{"groups": ['
            first=1
            while IFS= read -r line; do
                if [ "$first" -eq 1 ]; then
                    first=0
                else
                    printf ','
                fi
                printf '%s' "$line"
            done < "$tmpjson"
            printf ']}\n'
            rm -f "$tmpjson"
            trap - EXIT
        else
            if [ -z "$groups" ]; then
                echo "No groups defined"
            else
                echo "Groups:"
                echo "$groups" | while read -r g; do
                    count="$(list_mappings_for_group "$g" | wc -l | tr -d ' ')"
                    echo "  $g ($count sessions)"
                done
            fi
        fi
        return 0
    fi

    # Check if we have any mappings
    if [ ! -f "$HYDRA_MAP" ] || [ ! -s "$HYDRA_MAP" ]; then
        if [ -n "$json_output" ]; then
            printf '{"sessions": [], "total": 0, "active": 0, "dead": 0}\n'
        else
            echo "No active Hydra heads"
        fi
        return 0
    fi

    # Cache current session once before the loop (perf: issue #36)
    current_session="$(tmux display-message -p '#{session_name}' 2>/dev/null || true)"

    # Cache all tmux sessions once to avoid repeated subprocess calls (perf: v1.3.3)
    _cached_tmux_sessions="$(tmux list-sessions -F '#{session_name}' 2>/dev/null || true)"

    # Helper to check session existence against cache
    _session_exists_cached() {
        echo "$_cached_tmux_sessions" | grep -qx "$1" 2>/dev/null
    }

    # Cache current timestamp once to avoid repeated date calls (perf: v1.3.3)
    _cached_now="$(date +%s)"

    if [ -n "$json_output" ]; then
        # JSON output mode
        tmpjson="$(mktemp)"
        trap 'rm -f "$tmpjson"' EXIT
        total=0
        active=0
        dead=0

        while IFS=' ' read -r branch session ai group timestamp deps pr; do
            # Filter by group if specified
            if [ -n "$filter_group" ]; then
                if [ "$group" != "$filter_group" ]; then
                    continue
                fi
            fi

            total=$((total + 1))

            # Calculate duration (use cached timestamp for perf)
            duration_secs=0
            if [ -n "$timestamp" ] && [ "$timestamp" != "-" ]; then
                duration_secs="$((_cached_now - timestamp))"
            fi
            duration_human="$(format_duration "$duration_secs")"

            # Determine status (use cached check for perf)
            if _session_exists_cached "$session"; then
                status="active"
                active=$((active + 1))
            else
                status="dead"
                dead=$((dead + 1))
            fi

            # Check if current
            is_current="false"
            if [ "$session" = "$current_session" ]; then
                is_current="true"
            fi

            # Handle null/empty values for JSON
            ai_json="null"
            if [ -n "$ai" ] && [ "$ai" != "-" ]; then
                ai_json="\"$(json_escape "$ai")\""
            fi
            group_json="null"
            if [ -n "$group" ] && [ "$group" != "-" ]; then
                group_json="\"$(json_escape "$group")\""
            fi
            ts_json="null"
            if [ -n "$timestamp" ] && [ "$timestamp" != "-" ]; then
                ts_json="$timestamp"
            fi
            deps_json="null"
            if [ -n "$deps" ] && [ "$deps" != "-" ]; then
                deps_json="\"$(json_escape "$deps")\""
            fi
            pr_json="null"
            if [ -n "$pr" ] && [ "$pr" != "-" ]; then
                pr_json="$pr"
            fi

            # Build JSON object
            printf '{"branch": "%s", "session": "%s", "ai": %s, "group": %s, "status": "%s", "duration_seconds": %s, "duration_human": "%s", "timestamp": %s, "current": %s, "deps": %s, "pr": %s}\n' \
                "$(json_escape "$branch")" \
                "$(json_escape "$session")" \
                "$ai_json" \
                "$group_json" \
                "$status" \
                "$duration_secs" \
                "$duration_human" \
                "$ts_json" \
                "$is_current" \
                "$deps_json" \
                "$pr_json" >> "$tmpjson"
        done < "$HYDRA_MAP"

        # Output JSON
        printf '{"sessions": ['
        first=1
        while IFS= read -r line; do
            if [ "$first" -eq 1 ]; then
                first=0
            else
                printf ','
            fi
            printf '%s' "$line"
        done < "$tmpjson"
        printf '], "total": %s, "active": %s, "dead": %s}\n' "$total" "$active" "$dead"

        rm -f "$tmpjson"
        trap - EXIT
    else
        # Human-readable output mode
        if [ -n "$filter_group" ]; then
            echo "Active Hydra heads in group '$filter_group':"
        else
            echo "Active Hydra heads:"
        fi
        echo ""

        while IFS=' ' read -r branch session ai group timestamp deps pr; do
            # Filter by group if specified
            if [ -n "$filter_group" ]; then
                if [ "$group" != "$filter_group" ]; then
                    continue
                fi
            fi

            # Calculate duration if timestamp exists (use cached timestamp for perf)
            duration_str=""
            if [ -n "$timestamp" ] && [ "$timestamp" != "-" ]; then
                duration_secs="$((_cached_now - timestamp))"
                duration_str="$(format_duration "$duration_secs")"
            fi

            # Build status line
            status_line=""
            if [ -n "$duration_str" ]; then
                status_line="($duration_str)"
            fi
            if [ -n "$ai" ] && [ "$ai" != "-" ]; then
                if [ -n "$status_line" ]; then
                    status_line="$status_line [ai: $ai]"
                else
                    status_line="[ai: $ai]"
                fi
            fi
            if [ -n "$group" ] && [ "$group" != "-" ]; then
                if [ -n "$status_line" ]; then
                    status_line="$status_line [group: $group]"
                else
                    status_line="[group: $group]"
                fi
            fi
            # Show dependencies if present
            if [ -n "$deps" ] && [ "$deps" != "-" ]; then
                if [ -n "$status_line" ]; then
                    status_line="$status_line --after $deps"
                else
                    status_line="--after $deps"
                fi
            fi
            # Show PR if linked
            if [ -n "$pr" ] && [ "$pr" != "-" ]; then
                if [ -n "$status_line" ]; then
                    status_line="$status_line [PR #$pr]"
                else
                    status_line="[PR #$pr]"
                fi
            fi

            # Check if session still exists (use cached check for perf)
            if _session_exists_cached "$session"; then
                # Check if it's the current session
                if [ "$session" = "$current_session" ]; then
                    echo "* $branch -> $session $status_line (current)"
                else
                    echo "  $branch -> $session $status_line"
                fi
            else
                echo "  $branch -> $session $status_line (dead)"
            fi
        done < "$HYDRA_MAP"
    fi
}

cmd_switch() {
    # Interactive session switcher
    if [ ! -f "$HYDRA_MAP" ] || [ ! -s "$HYDRA_MAP" ]; then
        echo "No active Hydra heads to switch to"
        return 1
    fi
    
    # If inside tmux, use tmux's interactive switcher
    if [ -n "${TMUX:-}" ]; then
        # Build session list for fzf or simple menu
        sessions=""
        while IFS=' ' read -r branch session; do
            if tmux_session_exists "$session"; then
                sessions="$sessions$branch ($session)\n"
            fi
        done < "$HYDRA_MAP"
        
        if [ -z "$sessions" ]; then
            echo "No active sessions found"
            return 1
        fi
        
        # Use fzf if available, otherwise simple menu
        if command -v fzf >/dev/null 2>&1; then
            selection="$(printf "%b" "$sessions" | fzf --prompt="Switch to: " --height=10)"
        else
            echo "Active sessions:"
            i=1
            printf "%b" "$sessions" | while IFS= read -r line; do
                echo "$i) $line"
                i=$((i + 1))
            done
            session_count="$(printf "%b" "$sessions" | wc -l | tr -d ' ')"
            printf "Select session (1-%d): " "$session_count"
            read -r choice

            # Validate numeric input
            case "$choice" in
                ''|*[!0-9]*)
                    echo "Invalid selection: must be a number" >&2
                    return 1
                    ;;
            esac

            # Validate range
            if [ "$choice" -lt 1 ] || [ "$choice" -gt "$session_count" ]; then
                echo "Invalid selection: must be between 1 and $session_count" >&2
                return 1
            fi

            selection="$(printf "%b" "$sessions" | sed -n "${choice}p")"
        fi
        
        if [ -n "$selection" ]; then
            # Extract session name from selection
            session_name="$(echo "$selection" | sed 's/.*(\(.*\))/\1/')"
            switch_to_session "$session_name"
        fi
    else
        echo "Error: Not inside a tmux session"
        echo "Use 'tmux attach -t <session>' to attach to a session"
        return 1
    fi
}

cmd_group_create() {
    # Create a group and assign multiple branches to it
    if [ $# -lt 2 ]; then
        echo "Error: Group name and at least one branch required" >&2
        echo "Usage: hydra group create <group-name> <branch> [branch...]" >&2
        return 1
    fi

    group_name="$1"
    shift

    # Validate group name (alphanumeric, dash, underscore only)
    case "$group_name" in
        *[!a-zA-Z0-9_-]*)
            echo "Error: Invalid group name '$group_name' (use alphanumeric, dash, underscore)" >&2
            return 1
            ;;
    esac

    succeeded=0
    failed=0

    for branch in "$@"; do
        # Check if branch has a session
        session="$(get_session_for_branch "$branch" 2>/dev/null || true)"
        if [ -z "$session" ]; then
            echo "Warning: No session found for branch '$branch', skipping" >&2
            failed=$((failed + 1))
            continue
        fi

        if set_group "$branch" "$group_name"; then
            echo "Added '$branch' to group '$group_name'"
            succeeded=$((succeeded + 1))
        else
            echo "Error: Failed to add '$branch' to group" >&2
            failed=$((failed + 1))
        fi
    done

    echo ""
    echo "Group '$group_name': $succeeded added, $failed skipped"

    if [ "$succeeded" -eq 0 ]; then
        return 1
    fi
    return 0
}

cmd_group_wait() {
    # Wait for all sessions in a group to be killed/completed
    group_name=""
    timeout_seconds=3600
    poll_interval=5

    while [ $# -gt 0 ]; do
        case "$1" in
            -t|--timeout)
                shift
                timeout_seconds="${1:-3600}"
                shift
                ;;
            -p|--poll)
                shift
                poll_interval="${1:-5}"
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                return 1
                ;;
            *)
                if [ -z "$group_name" ]; then
                    group_name="$1"
                else
                    echo "Error: Unexpected argument '$1'" >&2
                    return 1
                fi
                shift
                ;;
        esac
    done

    if [ -z "$group_name" ]; then
        echo "Error: Group name required" >&2
        echo "Usage: hydra group wait <group-name> [-t <timeout>] [-p <poll>]" >&2
        return 1
    fi

    # Check if group has sessions
    mappings="$(list_mappings_for_group "$group_name")"
    if [ -z "$mappings" ]; then
        echo "No sessions found in group '$group_name'"
        return 0
    fi

    # Count total sessions
    total="$(printf '%s\n' "$mappings" | wc -l | tr -d ' ')"
    echo "Waiting for $total session(s) in group '$group_name' to complete..."
    echo "Timeout: ${timeout_seconds}s, Poll interval: ${poll_interval}s"

    start_time="$(date +%s)"

    while true; do
        now="$(date +%s)"
        elapsed=$((now - start_time))

        # Check timeout
        if [ "$elapsed" -ge "$timeout_seconds" ]; then
            echo ""
            echo "Error: Timeout after ${elapsed}s" >&2
            return 1
        fi

        # Count active sessions
        active=0
        pending=""
        # Re-read mappings in case sessions were killed
        mappings="$(list_mappings_for_group "$group_name")"

        if [ -n "$mappings" ]; then
            # Use a temp file to avoid subshell variable scope issues
            tmp_active="${HYDRA_HOME}/tmp_wait_$$"
            : > "$tmp_active"

            printf '%s\n' "$mappings" | while IFS=' ' read -r branch session _rest; do
                if tmux_session_exists "$session"; then
                    echo "$branch" >> "$tmp_active"
                fi
            done

            if [ -f "$tmp_active" ] && [ -s "$tmp_active" ]; then
                active="$(wc -l < "$tmp_active" | tr -d ' ')"
                pending="$(tr '\n' ',' < "$tmp_active" | sed 's/,$//')"
            fi
            rm -f "$tmp_active" 2>/dev/null
        fi

        if [ "$active" -eq 0 ]; then
            echo ""
            echo "All sessions in group '$group_name' have completed!"
            return 0
        fi

        printf "\r[%ds] Waiting for %d session(s): %s...    " "$elapsed" "$active" "$pending"

        sleep "$poll_interval"
    done
}

cmd_group_status() {
    # Show health status for a group
    group_name=""
    json_output=""

    while [ $# -gt 0 ]; do
        case "$1" in
            -j|--json)
                json_output="1"
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                return 1
                ;;
            *)
                if [ -z "$group_name" ]; then
                    group_name="$1"
                else
                    echo "Error: Unexpected argument '$1'" >&2
                    return 1
                fi
                shift
                ;;
        esac
    done

    if [ -z "$group_name" ]; then
        echo "Error: Group name required" >&2
        echo "Usage: hydra group status <group-name> [--json]" >&2
        return 1
    fi

    # Get mappings for group
    mappings="$(list_mappings_for_group "$group_name")"

    if [ -z "$mappings" ]; then
        if [ -n "$json_output" ]; then
            printf '{"group": "%s", "sessions": [], "total": 0, "active": 0, "dead": 0}\n' \
                "$(json_escape "$group_name")"
        else
            echo "No sessions found in group '$group_name'"
        fi
        return 0
    fi

    # Count stats
    total="$(printf '%s\n' "$mappings" | wc -l | tr -d ' ')"
    active=0
    dead=0

    # Build session info using temp file to avoid subshell issues
    tmp_sessions="${HYDRA_HOME}/tmp_status_$$"
    : > "$tmp_sessions"

    printf '%s\n' "$mappings" | while IFS=' ' read -r branch session ai _group timestamp deps pr; do
        if tmux_session_exists "$session"; then
            status="active"
        else
            status="dead"
        fi

        # Calculate duration
        duration_secs=0
        if [ -n "$timestamp" ] && [ "$timestamp" != "-" ]; then
            now="$(date +%s)"
            duration_secs=$((now - timestamp))
        fi

        # Store session info
        echo "$branch|$session|$status|${ai:-"-"}|$duration_secs|${deps:-"-"}|${pr:-"-"}" >> "$tmp_sessions"
    done

    if [ -n "$json_output" ]; then
        # JSON output
        printf '{"group": "%s", "sessions": [' "$(json_escape "$group_name")"
        first=1
        while IFS='|' read -r branch session status ai duration_secs deps pr; do
            [ "$first" -eq 1 ] && first=0 || printf ','

            # Handle optional fields
            ai_json="null"
            [ -n "$ai" ] && [ "$ai" != "-" ] && ai_json="\"$(json_escape "$ai")\""

            deps_json="null"
            [ -n "$deps" ] && [ "$deps" != "-" ] && deps_json="\"$(json_escape "$deps")\""

            pr_json="null"
            [ -n "$pr" ] && [ "$pr" != "-" ] && pr_json="$pr"

            printf '{"branch": "%s", "session": "%s", "status": "%s", "ai": %s, "duration_seconds": %s, "deps": %s, "pr": %s}' \
                "$(json_escape "$branch")" \
                "$(json_escape "$session")" \
                "$status" \
                "$ai_json" \
                "$duration_secs" \
                "$deps_json" \
                "$pr_json"

            # Count for summary
            case "$status" in
                active) active=$((active + 1)) ;;
                dead) dead=$((dead + 1)) ;;
            esac
        done < "$tmp_sessions"
        printf '], "total": %d, "active": %d, "dead": %d}\n' "$total" "$active" "$dead"
    else
        # Human-readable output
        echo "Group Status: $group_name"
        echo "=========================="
        echo ""

        while IFS='|' read -r branch session status ai duration_secs deps pr; do
            # Build status indicator
            case "$status" in
                active)
                    status_str="[OK]"
                    active=$((active + 1))
                    ;;
                dead)
                    status_str="[DEAD]"
                    dead=$((dead + 1))
                    ;;
            esac

            # Format duration
            duration_str=""
            if [ "$duration_secs" -gt 0 ]; then
                duration_str="$(format_duration "$duration_secs")"
            fi

            # Build info line
            info=""
            [ -n "$duration_str" ] && info="($duration_str)"
            [ -n "$ai" ] && [ "$ai" != "-" ] && info="$info [ai: $ai]"
            [ -n "$deps" ] && [ "$deps" != "-" ] && info="$info [deps: $deps]"
            [ -n "$pr" ] && [ "$pr" != "-" ] && info="$info [PR #$pr]"

            printf "  %-6s %s -> %s %s\n" "$status_str" "$branch" "$session" "$info"
        done < "$tmp_sessions"

        echo ""
        echo "Summary: $total total, $active active, $dead dead"
    fi

    rm -f "$tmp_sessions" 2>/dev/null
}

cmd_group() {
    # Check for subcommand pattern first
    case "${1:-}" in
        create)
            shift
            cmd_group_create "$@"
            return $?
            ;;
        wait)
            shift
            cmd_group_wait "$@"
            return $?
            ;;
        status)
            shift
            cmd_group_status "$@"
            return $?
            ;;
    esac

    # Original logic: Assign or show group for a branch
    if [ $# -lt 1 ]; then
        echo "Error: Branch name or subcommand required" >&2
        echo "Usage: hydra group <branch> [<group-name>]" >&2
        echo "       hydra group <branch> --clear" >&2
        echo "       hydra group create <name> <branch> [branch...]" >&2
        echo "       hydra group wait <name> [-t <timeout>]" >&2
        echo "       hydra group status <name> [--json]" >&2
        return 1
    fi

    branch="$1"
    shift

    # Check if branch exists in mappings
    session="$(get_session_for_branch "$branch" 2>/dev/null || true)"
    if [ -z "$session" ]; then
        echo "Error: No session found for branch '$branch'" >&2
        return 1
    fi

    # If no group specified, show current group
    if [ $# -eq 0 ]; then
        current_group="$(get_group_for_branch "$branch" 2>/dev/null || true)"
        if [ -n "$current_group" ]; then
            echo "Group for '$branch': $current_group"
        else
            echo "No group assigned to '$branch'"
        fi
        return 0
    fi

    # Handle --clear
    if [ "$1" = "--clear" ]; then
        if set_group "$branch" ""; then
            echo "Cleared group for '$branch'"
        else
            echo "Error: Failed to clear group" >&2
            return 1
        fi
        return 0
    fi

    # Set the group
    new_group="$1"
    if set_group "$branch" "$new_group"; then
        echo "Set group for '$branch' to '$new_group'"
    else
        echo "Error: Failed to set group" >&2
        return 1
    fi
}

cmd_send() {
    # Send a message to another session's inbox
    if [ $# -lt 2 ]; then
        echo "Error: Target branch and message required" >&2
        echo "Usage: hydra send <branch> <message>" >&2
        return 1
    fi

    target="$1"
    shift
    message="$*"

    # Validate target has a session (warn only)
    session="$(get_session_for_branch "$target" 2>/dev/null || true)"
    if [ -z "$session" ]; then
        echo "Warning: No active session for '$target'" >&2
    fi

    if send_message "$target" "$message"; then
        echo "Message sent to '$target'"
    else
        echo "Error: Failed to send message" >&2
        return 1
    fi
}

cmd_recv() {
    # Receive messages for current session
    peek=0
    json_output=""

    while [ $# -gt 0 ]; do
        case "$1" in
            --peek)
                peek=1
                shift
                ;;
            -j|--json)
                json_output="1"
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: hydra recv [--peek] [--json]" >&2
                return 1
                ;;
            *)
                echo "Error: Unexpected argument '$1'" >&2
                return 1
                ;;
        esac
    done

    # Get current branch
    current_session="$(get_current_session 2>/dev/null || true)"
    if [ -z "$current_session" ]; then
        echo "Error: Not in a Hydra session" >&2
        return 1
    fi

    branch="$(get_branch_for_session "$current_session" 2>/dev/null || true)"
    if [ -z "$branch" ]; then
        echo "Error: Cannot determine branch for current session" >&2
        return 1
    fi

    if [ -n "$json_output" ]; then
        # JSON output mode
        msg_dir="$(get_message_dir "$branch")"
        queue_dir="$msg_dir/queue"

        printf '{"branch": "%s", "messages": [' "$(json_escape "$branch")"

        first=1
        if [ -d "$queue_dir" ]; then
            for msg_file in "$queue_dir"/*; do
                [ -f "$msg_file" ] || continue

                filename="$(basename "$msg_file")"
                timestamp="$(echo "$filename" | cut -d'_' -f1)"
                sender="$(echo "$filename" | cut -d'_' -f2)"
                message="$(cat "$msg_file")"

                if [ "$first" -eq 1 ]; then
                    first=0
                else
                    printf ','
                fi

                printf '{"from": "%s", "timestamp": %s, "message": "%s"}' \
                    "$(json_escape "$sender")" \
                    "$timestamp" \
                    "$(json_escape "$message")"

                # Remove if not peeking
                if [ "$peek" -eq 0 ]; then
                    rm -f "$msg_file"
                fi
            done
        fi

        printf ']}\n'
    else
        # Human-readable output
        recv_opts=""
        [ "$peek" -eq 1 ] && recv_opts="--peek"

        if recv_messages "$branch" $recv_opts; then
            : # Messages printed by recv_messages
        else
            echo "No messages"
        fi
    fi
}

cmd_pr() {
    # Create or show PR for a branch
    branch="$1"

    # If no branch specified, use current session's branch
    if [ -z "$branch" ]; then
        current_session="$(tmux display-message -p '#{session_name}' 2>/dev/null || true)"
        if [ -z "$current_session" ]; then
            echo "Error: Not in a Hydra session and no branch specified" >&2
            echo "Usage: hydra pr [<branch>]" >&2
            return 1
        fi
        branch="$(get_branch_for_session "$current_session" 2>/dev/null || true)"
        if [ -z "$branch" ]; then
            echo "Error: Could not determine branch for current session" >&2
            return 1
        fi
    fi

    # Check if branch exists in mappings
    session="$(get_session_for_branch "$branch" 2>/dev/null || true)"
    if [ -z "$session" ]; then
        echo "Error: No session found for branch '$branch'" >&2
        return 1
    fi

    # Check if already has PR
    existing_pr="$(get_pr_for_branch "$branch" 2>/dev/null || true)"
    if [ -n "$existing_pr" ] && [ "$existing_pr" != "-" ]; then
        echo "Branch '$branch' already has PR #$existing_pr"
        printf "Open in browser? [y/N] "
        read -r response
        case "$response" in
            [yY][eE][sS]|[yY])
                require github
                gh pr view "$existing_pr" --web
                ;;
        esac
        return 0
    fi

    # Check gh CLI
    require github
    if ! check_gh_cli; then
        return 1
    fi

    # Create new PR
    echo "Creating PR for branch '$branch'..."
    new_pr="$(create_pr_for_branch "$branch")" || return 1

    # Store PR number in state
    set_pr_for_branch "$branch" "$new_pr"

    echo "Created PR #$new_pr"
    printf "Open in browser? [y/N] "
    read -r response
    case "$response" in
        [yY][eE][sS]|[yY])
            gh pr view "$new_pr" --web
            ;;
    esac
}

cmd_tail() {
    # Watch output from a session's pane
    lines=50
    follow=false
    branch=""

    while [ $# -gt 0 ]; do
        case "$1" in
            -n|--lines)
                shift
                lines="$1"
                shift
                ;;
            -f|--follow)
                follow=true
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: hydra tail <branch> [-n|--lines <N>] [-f|--follow]" >&2
                return 1
                ;;
            *)
                if [ -z "$branch" ]; then
                    branch="$1"
                else
                    echo "Error: Too many arguments" >&2
                    return 1
                fi
                shift
                ;;
        esac
    done

    if [ -z "$branch" ]; then
        echo "Error: Branch name required" >&2
        echo "Usage: hydra tail <branch> [-n|--lines <N>] [-f|--follow]" >&2
        return 1
    fi

    # Get session for branch
    session="$(get_session_for_branch "$branch" 2>/dev/null || true)"
    if [ -z "$session" ]; then
        echo "Error: No session found for branch '$branch'" >&2
        return 1
    fi

    if ! tmux_session_exists "$session"; then
        echo "Error: Session '$session' is not running" >&2
        return 1
    fi

    if [ "$follow" = true ]; then
        # Follow mode - continuously capture and display
        echo "Tailing session '$session' (Ctrl-C to exit)..."
        echo "---"
        trap 'echo ""; echo "---"; echo "Stopped tailing."; exit 0' INT
        last_output=""
        while true; do
            current_output="$(tmux capture-pane -t "$session" -p -S -"$lines" 2>/dev/null || true)"
            if [ "$current_output" != "$last_output" ]; then
                # Clear screen and show new output
                printf '\033[2J\033[H'
                echo "=== $branch ($session) ==="
                echo "$current_output"
            fi
            last_output="$current_output"
            sleep 1
        done
    else
        # One-shot capture
        echo "=== $branch ($session) - last $lines lines ==="
        tmux capture-pane -t "$session" -p -S -"$lines" 2>/dev/null || true
    fi
}

cmd_broadcast() {
    # Send a command to all sessions or a group
    broadcast_group=""
    command_text=""

    while [ $# -gt 0 ]; do
        case "$1" in
            -g|--group)
                shift
                broadcast_group="$1"
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: hydra broadcast [-g|--group <name>] <command>" >&2
                return 1
                ;;
            *)
                # Remaining args are the command
                command_text="$*"
                break
                ;;
        esac
    done

    if [ -z "$command_text" ]; then
        echo "Error: Command required" >&2
        echo "Usage: hydra broadcast [-g|--group <name>] <command>" >&2
        return 1
    fi

    # Get sessions to broadcast to
    if [ -n "$broadcast_group" ]; then
        mappings="$(list_mappings_for_group "$broadcast_group")"
        if [ -z "$mappings" ]; then
            echo "No sessions found in group '$broadcast_group'"
            return 1
        fi
        echo "Broadcasting to group '$broadcast_group'..."
    else
        if [ ! -f "$HYDRA_MAP" ] || [ ! -s "$HYDRA_MAP" ]; then
            echo "No active sessions"
            return 1
        fi
        mappings="$(cat "$HYDRA_MAP")"
        echo "Broadcasting to all sessions..."
    fi

    # Use temp file for count to avoid subshell variable loss
    tmpcount="$(mktemp)"
    printf "0" > "$tmpcount"

    echo "$mappings" | while IFS=' ' read -r branch session _ai _group; do
        if tmux_session_exists "$session"; then
            echo "  Sending to $branch ($session)..."
            tmux send-keys -t "$session" "$command_text" Enter 2>/dev/null || true
            # Increment count in file
            _cnt="$(cat "$tmpcount")"
            printf "%d" "$((_cnt + 1))" > "$tmpcount"
        fi
    done

    count="$(cat "$tmpcount")"
    rm -f "$tmpcount"

    echo "Sent to $count session(s)"
}

cmd_wait_idle() {
    # Wait for sessions to become idle (no output for N seconds)
    idle_seconds=10
    timeout_seconds=300
    wait_group=""

    while [ $# -gt 0 ]; do
        case "$1" in
            -s|--seconds)
                shift
                idle_seconds="$1"
                shift
                ;;
            -t|--timeout)
                shift
                timeout_seconds="$1"
                shift
                ;;
            -g|--group)
                shift
                wait_group="$1"
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: hydra wait-idle [-g|--group <name>] [-s|--seconds <N>] [-t|--timeout <N>]" >&2
                return 1
                ;;
            *)
                echo "Error: Unexpected argument '$1'" >&2
                return 1
                ;;
        esac
    done

    # Get sessions to monitor
    if [ -n "$wait_group" ]; then
        mappings="$(list_mappings_for_group "$wait_group")"
        if [ -z "$mappings" ]; then
            echo "No sessions found in group '$wait_group'"
            return 1
        fi
        echo "Waiting for group '$wait_group' to become idle..."
    else
        if [ ! -f "$HYDRA_MAP" ] || [ ! -s "$HYDRA_MAP" ]; then
            echo "No active sessions"
            return 0
        fi
        mappings="$(cat "$HYDRA_MAP")"
        echo "Waiting for all sessions to become idle..."
    fi

    echo "Idle threshold: ${idle_seconds}s, timeout: ${timeout_seconds}s"

    start_time="$(date +%s)"

    # Track last output hash for each session
    tmpdir="$(mktemp -d)"
    trap 'rm -rf "$tmpdir"' EXIT INT TERM

    # Initialize tracking
    echo "$mappings" | while IFS=' ' read -r branch session _ai _group; do
        if tmux_session_exists "$session"; then
            echo "$start_time" > "$tmpdir/$session.time"
            tmux capture-pane -t "$session" -p 2>/dev/null | cksum > "$tmpdir/$session.hash"
        fi
    done

    while true; do
        current_time="$(date +%s)"
        elapsed=$((current_time - start_time))

        if [ "$elapsed" -ge "$timeout_seconds" ]; then
            echo "Timeout after ${timeout_seconds}s"
            return 1
        fi

        # Use file to track idle state across subshell
        echo "idle" > "$tmpdir/status"

        echo "$mappings" | while IFS=' ' read -r _branch session _ai _group; do
            if ! tmux_session_exists "$session"; then
                continue
            fi

            # Get current output hash
            current_hash="$(tmux capture-pane -t "$session" -p 2>/dev/null | cksum)"
            last_hash="$(cat "$tmpdir/$session.hash" 2>/dev/null || echo "")"

            if [ "$current_hash" != "$last_hash" ]; then
                # Output changed, reset idle timer
                echo "$current_time" > "$tmpdir/$session.time"
                echo "$current_hash" > "$tmpdir/$session.hash"
                echo "busy" > "$tmpdir/status"
            else
                # Check if idle long enough
                last_change="$(cat "$tmpdir/$session.time" 2>/dev/null || echo "$current_time")"
                idle_time=$((current_time - last_change))
                if [ "$idle_time" -lt "$idle_seconds" ]; then
                    echo "busy" > "$tmpdir/status"
                fi
            fi
        done

        status="$(cat "$tmpdir/status")"
        if [ "$status" = "idle" ]; then
            echo ""
            echo "All sessions idle for ${idle_seconds}s"
            return 0
        fi

        printf "\r[%ds] Waiting...  " "$elapsed"
        sleep 2
    done
}

cmd_kill() {
    # Parse arguments
    branch=""
    kill_all=false
    force=false
    kill_group=""

    while [ $# -gt 0 ]; do
        case "$1" in
            --all)
                kill_all=true
                shift
                ;;
            --force)
                force=true
                shift
                ;;
            -g|--group)
                shift
                kill_group="$1"
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: hydra kill <branch>" >&2
                echo "       hydra kill --all [--force]" >&2
                echo "       hydra kill -g|--group <name> [--force]" >&2
                return 1
                ;;
            *)
                if [ -z "$branch" ]; then
                    branch="$1"
                else
                    echo "Error: Too many arguments" >&2
                    echo "Usage: hydra kill <branch>" >&2
                    echo "       hydra kill --all [--force]" >&2
                    echo "       hydra kill -g|--group <name> [--force]" >&2
                    return 1
                fi
                shift
                ;;
        esac
    done

    # Check mutual exclusivity
    if [ "$kill_all" = true ] && [ -n "$branch" ]; then
        echo "Error: Cannot specify both branch name and --all" >&2
        echo "Usage: hydra kill <branch>" >&2
        echo "       hydra kill --all [--force]" >&2
        echo "       hydra kill -g|--group <name> [--force]" >&2
        return 1
    fi

    if [ -n "$kill_group" ] && [ -n "$branch" ]; then
        echo "Error: Cannot specify both branch name and --group" >&2
        return 1
    fi

    if [ -n "$kill_group" ] && [ "$kill_all" = true ]; then
        echo "Error: Cannot specify both --all and --group" >&2
        return 1
    fi

    # If --all flag is set, delegate to kill_all_sessions
    if [ "$kill_all" = true ]; then
        kill_all_sessions "$force"
        return $?
    fi

    # If --group is set, kill all sessions in the group
    if [ -n "$kill_group" ]; then
        mappings="$(list_mappings_for_group "$kill_group")"
        if [ -z "$mappings" ]; then
            echo "No sessions found in group '$kill_group'"
            return 1
        fi

        count="$(echo "$mappings" | wc -l | tr -d ' ')"

        # Confirm unless forced
        if [ "$force" != true ] && [ -t 0 ] && [ -z "${CI:-}" ] && [ -z "${HYDRA_NONINTERACTIVE:-}" ]; then
            printf "Kill all %s sessions in group '%s'? [y/N] " "$count" "$kill_group"
            read -r response
            case "$response" in
                [yY][eE][sS]|[yY]) ;;
                *)
                    echo "Aborted"
                    return 0
                    ;;
            esac
        fi

        echo "Killing $count sessions in group '$kill_group'..."
        echo "$mappings" | while IFS=' ' read -r b _s _a _g; do
            echo "  Killing $b..."
            kill_single_head "$b" 2>/dev/null || true
        done
        echo "Done"
        return 0
    fi

    # Original single branch kill logic
    if [ -z "$branch" ]; then
        echo "Error: Branch name required" >&2
        echo "Usage: hydra kill <branch>" >&2
        echo "       hydra kill --all [--force]" >&2
        echo "       hydra kill -g|--group <name> [--force]" >&2
        return 1
    fi
    
    # Get session for branch
    session="$(get_session_for_branch "$branch" 2>/dev/null || true)"
    
    if [ -z "$session" ]; then
        echo "No session found for branch '$branch'"
        return 1
    fi
    
    # Skip confirmation in non-interactive environments (CI, tests)
    if [ -t 0 ] && [ -z "${CI:-}" ] && [ -z "${HYDRA_NONINTERACTIVE:-}" ]; then
        # Interactive mode - ask for confirmation
        printf "Kill hydra head '%s' (session: %s)? [y/N] " "$branch" "$session"
        read -r response
        case "$response" in
            [yY][eE][sS]|[yY])
                ;;
            *)
                echo "Aborted"
                return 0
                ;;
        esac
    else
        # Non-interactive mode - proceed without confirmation
        echo "Killing hydra head '$branch' (session: $session) [non-interactive mode]"
    fi
    
    # Use kill_single_head helper for the actual kill
    if kill_single_head "$branch" "$session"; then
        echo "Hydra head '$branch' has been killed"
    else
        echo "Failed to kill hydra head '$branch'" >&2
        return 1
    fi
}

cmd_regenerate() {
    echo "Regenerating tmux sessions for existing worktrees..."
    
    # Best-effort cleanup of stale session-name locks
    cleanup_stale_locks 2>/dev/null || true

    # Get repository root
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "Error: Not in a git repository" >&2
        return 1
    fi
    
    repo_root="$(git rev-parse --show-toplevel)"
    parent_dir="$(dirname "$repo_root")"
    
    # Find all hydra worktrees
    regenerated=0
    skipped=0
    
    for dir in "$parent_dir"/hydra-*; do
        if [ ! -d "$dir" ]; then
            continue
        fi
        
        # Extract branch name from directory
        branch="$(basename "$dir" | sed 's/^hydra-//')"
        
        # Check if session already exists
        existing_session="$(get_session_for_branch "$branch" 2>/dev/null || true)"
        if [ -n "$existing_session" ] && tmux_session_exists "$existing_session"; then
            echo "Session already exists for '$branch', skipping..."
            skipped=$((skipped + 1))
            continue
        fi
        
        # Generate session name
        session="$(generate_session_name "$branch")"
        
        # Create session
        echo "Creating session '$session' for branch '$branch'..."
        if create_session "$session" "$dir"; then
            # Preserve any stored AI tool for this branch
            stored_ai="$(get_ai_for_branch "$branch" 2>/dev/null || true)"
            add_mapping "$branch" "$session" "$stored_ai"
            regenerated=$((regenerated + 1))
            # Release any reserved session name lock
            release_session_lock "$session" 2>/dev/null || true
            # Apply YAML config if available; else apply custom/built-in default
            repo_root_for_dir="$(git -C "$dir" rev-parse --show-toplevel 2>/dev/null || dirname "$dir")"
            if [ -z "${HYDRA_DISABLE_YAML:-}" ] && cfgpath="$(locate_yaml_config "$dir" "$repo_root_for_dir" 2>/dev/null || true)" && [ -n "$cfgpath" ]; then
                apply_yaml_config "$cfgpath" "$session" "$dir" "$repo_root_for_dir"
            else
                apply_custom_layout_or_default "default" "$session" "$dir" "$repo_root_for_dir"
                # Optionally run startup commands on regenerate only if explicitly enabled
                if [ -n "${HYDRA_REGENERATE_RUN_STARTUP:-}" ]; then
                    run_startup_commands "$session" "$dir" "$repo_root_for_dir"
                fi
            fi
            # Optionally auto-launch stored AI tool in the regenerated session
            if [ -n "$stored_ai" ]; then
                if validate_ai_command "$stored_ai"; then
                    echo "Starting $stored_ai in session '$session'..." >&2
                    send_keys_to_session "$session" "$stored_ai"
                else
                    echo "Warning: Stored AI tool '$stored_ai' is invalid; skipping launch" >&2
                fi
            fi
        else
            echo "Failed to create session for '$branch'" >&2
            # Release any reserved session name lock
            release_session_lock "$session" 2>/dev/null || true
        fi
    done
    
    echo ""
    echo "Regeneration complete:"
    echo "  Created: $regenerated"
    echo "  Skipped: $skipped"
}

cmd_status() {
    # Parse arguments
    json_output=""
    while [ $# -gt 0 ]; do
        case "$1" in
            -j|--json)
                json_output="1"
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: hydra status [--json]" >&2
                exit 1
                ;;
            *)
                echo "Error: Unexpected argument '$1'" >&2
                exit 1
                ;;
        esac
    done

    # Collect system info
    tmux_ver="$(tmux -V 2>/dev/null || echo "Not installed")"
    git_ver="$(git --version 2>/dev/null | sed 's/git version //' || echo "Not installed")"

    # Repository info
    repo_path=""
    current_branch=""
    if git rev-parse --git-dir >/dev/null 2>&1; then
        repo_path="$(git rev-parse --show-toplevel)"
        current_branch="$(git branch --show-current 2>/dev/null || echo "Unknown")"
    fi

    if [ -n "$json_output" ]; then
        # JSON output mode
        tmpjson="$(mktemp)"
        trap 'rm -f "$tmpjson"' EXIT
        active=0
        dead=0

        if [ -f "$HYDRA_MAP" ] && [ -s "$HYDRA_MAP" ]; then
            while IFS=' ' read -r branch session ai group timestamp; do
                # Calculate duration
                duration_secs=0
                if [ -n "$timestamp" ] && [ "$timestamp" != "-" ]; then
                    duration_secs="$(get_duration_since "$timestamp")"
                fi

                # Determine status
                if tmux_session_exists "$session"; then
                    status="active"
                    active=$((active + 1))
                else
                    status="dead"
                    dead=$((dead + 1))
                fi

                # Handle null/empty values
                ai_json="null"
                if [ -n "$ai" ] && [ "$ai" != "-" ]; then
                    ai_json="\"$(json_escape "$ai")\""
                fi

                printf '{"branch": "%s", "session": "%s", "ai": %s, "status": "%s", "duration_seconds": %s}\n' \
                    "$(json_escape "$branch")" \
                    "$(json_escape "$session")" \
                    "$ai_json" \
                    "$status" \
                    "$duration_secs" >> "$tmpjson"
            done < "$HYDRA_MAP"
        fi

        # Build final JSON
        printf '{'
        printf '"system": {"hydra_version": "%s", "tmux_version": "%s", "git_version": "%s"}' \
            "$(json_escape "$HYDRA_VERSION")" \
            "$(json_escape "$tmux_ver")" \
            "$(json_escape "$git_ver")"
        printf ', "repository": {"path": "%s", "branch": "%s"}' \
            "$(json_escape "$repo_path")" \
            "$(json_escape "$current_branch")"
        printf ', "sessions": ['

        first=1
        if [ -f "$tmpjson" ]; then
            while IFS= read -r line; do
                if [ "$first" -eq 1 ]; then
                    first=0
                else
                    printf ','
                fi
                printf '%s' "$line"
            done < "$tmpjson"
        fi

        printf '], "summary": {"active": %s, "dead": %s}' "$active" "$dead"
        printf '}\n'

        rm -f "$tmpjson"
        trap - EXIT
    else
        # Human-readable output
        echo "Hydra Status Report"
        echo "=================="
        echo ""

        echo "System Information:"
        echo "  Hydra Version: $HYDRA_VERSION"
        echo "  tmux Version: $tmux_ver"
        echo "  Git Version: $git_ver"
        echo ""

        if [ -n "$repo_path" ]; then
            echo "Repository:"
            echo "  Path: $repo_path"
            echo "  Current Branch: $current_branch"
            echo ""
        fi

        if [ ! -f "$HYDRA_MAP" ] || [ ! -s "$HYDRA_MAP" ]; then
            echo "No active Hydra heads"
            return 0
        fi

        echo "Active Heads:"
        active=0
        dead=0

        while IFS=' ' read -r branch session ai group timestamp; do
            # Calculate duration if timestamp exists
            duration_str=""
            if [ -n "$timestamp" ] && [ "$timestamp" != "-" ]; then
                duration_secs="$(get_duration_since "$timestamp")"
                duration_str="$(format_duration "$duration_secs")"
            fi

            # Build info string
            info=""
            if [ -n "$duration_str" ]; then
                info="($duration_str)"
            fi
            if [ -n "$ai" ] && [ "$ai" != "-" ]; then
                if [ -n "$info" ]; then
                    info="$info [ai: $ai]"
                else
                    info="[ai: $ai]"
                fi
            fi

            if tmux_session_exists "$session"; then
                echo "  [OK] $branch -> $session $info"
                active=$((active + 1))
            else
                echo "  [DEAD] $branch -> $session $info"
                dead=$((dead + 1))
            fi
        done < "$HYDRA_MAP"

        echo ""
        echo "Summary:"
        echo "  Active Sessions: $active"
        echo "  Dead Sessions: $dead"

        if [ "$dead" -gt 0 ]; then
            echo ""
            echo "Note: Dead sessions can be regenerated with 'hydra regenerate'"
        fi
    fi
}

cmd_doctor() {
    echo "Hydra Doctor - System Health Check"
    echo "================================="
    echo ""
    
    # Check dependencies
    echo "Checking dependencies..."
    errors=0
    
    # Check tmux
    if command -v tmux >/dev/null 2>&1; then
        if check_tmux_version; then
            echo "  [OK] tmux $(tmux -V)"
        else
            echo "  [FAIL] tmux version too old (need 3.0+)"
            errors=$((errors + 1))
        fi
    else
        echo "  [FAIL] tmux not installed"
        errors=$((errors + 1))
    fi
    
    # Check git
    if command -v git >/dev/null 2>&1; then
        echo "  [OK] $(git --version)"
    else
        echo "  [FAIL] git not installed"
        errors=$((errors + 1))
    fi
    
    # Check performance
    echo ""
    echo "Running performance tests..."
    
    # Test command dispatch
    start_time=$(date +%s%N 2>/dev/null || date +%s)
    "$0" version >/dev/null 2>&1
    end_time=$(date +%s%N 2>/dev/null || date +%s)
    
    if [ ${#start_time} -gt 10 ]; then
        # Nanosecond precision available
        elapsed=$(( (end_time - start_time) / 1000000 ))
        echo "  Command dispatch: ${elapsed}ms"
    else
        # Only second precision
        echo "  Command dispatch: <1000ms (no precise timing available)"
    fi
    
    # Check state file
    echo ""
    echo "Checking state management..."
    if [ -f "$HYDRA_MAP" ]; then
        echo "  [OK] State file exists: $HYDRA_MAP"
        echo "    Size: $(wc -c < "$HYDRA_MAP") bytes"
        echo "    Entries: $(wc -l < "$HYDRA_MAP" | tr -d ' ')"
    else
        echo "  [INFO] No state file (this is normal for new installations)"
    fi

    # Consistency checks
    echo ""
    echo "Consistency Checks:"
    consistency_issues=0

    # Check for dead sessions (mapping exists but tmux session doesn't)
    dead_count=0
    if [ -f "$HYDRA_MAP" ] && [ -s "$HYDRA_MAP" ]; then
        while IFS=' ' read -r branch session _ai _group _ts; do
            if [ -n "$session" ] && ! tmux_session_exists "$session"; then
                dead_count=$((dead_count + 1))
            fi
        done < "$HYDRA_MAP"
    fi
    if [ "$dead_count" -gt 0 ]; then
        print_warning "Dead sessions: $dead_count (run 'hydra regenerate' to restore)"
        consistency_issues=$((consistency_issues + 1))
    else
        print_success "No dead sessions"
    fi

    # Check for orphaned worktrees (worktree exists without mapping)
    orphan_wt=0
    repo_root="$(get_repo_root 2>/dev/null || true)"
    if [ -n "$repo_root" ]; then
        # Get all hydra worktrees
        parent_dir="$(dirname "$repo_root")"
        repo_name="$(basename "$repo_root")"
        for wt_dir in "$parent_dir/${repo_name}-"*; do
            [ -d "$wt_dir" ] || continue
            # Extract branch from worktree path
            wt_branch="${wt_dir#"$parent_dir/${repo_name}-"}"
            # Check if this branch has a mapping
            if [ -f "$HYDRA_MAP" ]; then
                if ! grep -q "^$wt_branch " "$HYDRA_MAP" 2>/dev/null; then
                    orphan_wt=$((orphan_wt + 1))
                fi
            else
                orphan_wt=$((orphan_wt + 1))
            fi
        done
    fi
    if [ "$orphan_wt" -gt 0 ]; then
        print_warning "Orphaned worktrees: $orphan_wt (run 'hydra cleanup' to remove)"
        consistency_issues=$((consistency_issues + 1))
    else
        print_success "No orphaned worktrees"
    fi

    # Check for stale locks
    stale_lock_count=0
    if [ -d "$HYDRA_HOME/locks" ]; then
        for lock_dir in "$HYDRA_HOME/locks"/*; do
            [ -d "$lock_dir" ] || continue
            # Check if lock is older than 60 seconds
            lock_age=0
            if [ -f "$lock_dir/pid" ]; then
                if command -v stat >/dev/null 2>&1; then
                    if stat --version 2>&1 | grep -q GNU; then
                        lock_mtime="$(stat -c %Y "$lock_dir/pid" 2>/dev/null || echo 0)"
                    else
                        lock_mtime="$(stat -f %m "$lock_dir/pid" 2>/dev/null || echo 0)"
                    fi
                    now="$(date +%s)"
                    lock_age=$((now - lock_mtime))
                fi
            fi
            if [ "$lock_age" -gt 60 ]; then
                stale_lock_count=$((stale_lock_count + 1))
            fi
        done
    fi
    if [ "$stale_lock_count" -gt 0 ]; then
        print_warning "Stale locks: $stale_lock_count (run 'hydra cleanup' to remove)"
        consistency_issues=$((consistency_issues + 1))
    else
        print_success "No stale locks"
    fi

    # Summary
    echo ""
    if [ "$errors" -eq 0 ] && [ "$consistency_issues" -eq 0 ]; then
        echo "[OK] All checks passed! Hydra is ready to use."
    elif [ "$errors" -eq 0 ]; then
        echo "[WARN] Found $consistency_issues consistency issue(s). Run 'hydra cleanup' to fix."
    else
        echo "[FAIL] Found $errors issue(s). Please install missing dependencies."
        return 1
    fi
}

# Cleanup orphaned worktrees, stale locks, and dead mappings
# Usage: cmd_cleanup
cmd_cleanup() {
    echo "Hydra Cleanup"
    echo "============="
    echo ""

    cleaned_total=0

    # Clean stale locks
    echo "Cleaning stale locks..."
    stale_cleaned=0
    if [ -d "$HYDRA_HOME/locks" ]; then
        for lock_dir in "$HYDRA_HOME/locks"/*; do
            [ -d "$lock_dir" ] || continue
            lock_age=0
            if [ -f "$lock_dir/pid" ]; then
                if command -v stat >/dev/null 2>&1; then
                    if stat --version 2>&1 | grep -q GNU; then
                        lock_mtime="$(stat -c %Y "$lock_dir/pid" 2>/dev/null || echo 0)"
                    else
                        lock_mtime="$(stat -f %m "$lock_dir/pid" 2>/dev/null || echo 0)"
                    fi
                    now="$(date +%s)"
                    lock_age=$((now - lock_mtime))
                fi
            fi
            if [ "$lock_age" -gt 60 ]; then
                rm -rf "$lock_dir"
                stale_cleaned=$((stale_cleaned + 1))
            fi
        done
    fi
    print_info "Cleaned $stale_cleaned stale lock(s)"
    cleaned_total=$((cleaned_total + stale_cleaned))

    # Clean dead session mappings
    echo ""
    echo "Cleaning dead session mappings..."
    dead_cleaned=0
    if [ -f "$HYDRA_MAP" ] && [ -s "$HYDRA_MAP" ]; then
        tmpfile="$(mktemp)"
        while IFS=' ' read -r branch session ai group timestamp; do
            if [ -n "$session" ] && tmux_session_exists "$session"; then
                # Session is alive, keep it
                if [ -n "$timestamp" ]; then
                    echo "$branch $session ${ai:--} ${group:--} $timestamp" >> "$tmpfile"
                else
                    echo "$branch $session ${ai:--} ${group:--}" >> "$tmpfile"
                fi
            else
                # Session is dead, skip it (will be removed)
                dead_cleaned=$((dead_cleaned + 1))
                echo "  Removed mapping: $branch -> $session"
            fi
        done < "$HYDRA_MAP"
        mv "$tmpfile" "$HYDRA_MAP"
        _invalidate_state_cache
    fi
    print_info "Cleaned $dead_cleaned dead mapping(s)"
    cleaned_total=$((cleaned_total + dead_cleaned))

    # Find and offer to clean orphaned worktrees
    echo ""
    echo "Checking for orphaned worktrees..."
    orphan_list=""
    repo_root="$(get_repo_root 2>/dev/null || true)"
    if [ -n "$repo_root" ]; then
        parent_dir="$(dirname "$repo_root")"
        repo_name="$(basename "$repo_root")"
        for wt_dir in "$parent_dir/${repo_name}-"*; do
            [ -d "$wt_dir" ] || continue
            wt_branch="${wt_dir#"$parent_dir/${repo_name}-"}"
            # Check if this branch has a mapping
            has_mapping=false
            if [ -f "$HYDRA_MAP" ] && [ -s "$HYDRA_MAP" ]; then
                if grep -q "^$wt_branch " "$HYDRA_MAP" 2>/dev/null; then
                    has_mapping=true
                fi
            fi
            if [ "$has_mapping" = false ]; then
                orphan_list="$orphan_list$wt_dir
"
            fi
        done
    fi

    if [ -n "$orphan_list" ]; then
        orphan_count="$(echo "$orphan_list" | grep -c . || true)"
        echo "Found $orphan_count orphaned worktree(s):"
        echo "$orphan_list" | while IFS= read -r wt; do
            [ -z "$wt" ] && continue
            echo "  $wt"
        done

        # Ask for confirmation in interactive mode
        if [ -t 0 ] && [ -z "${CI:-}" ] && [ -z "${HYDRA_NONINTERACTIVE:-}" ]; then
            printf "\nRemove these orphaned worktrees? [y/N] "
            read -r response
            case "$response" in
                [yY][eE][sS]|[yY])
                    orphan_cleaned=0
                    echo "$orphan_list" | while IFS= read -r wt; do
                        [ -z "$wt" ] && continue
                        echo "  Removing $wt..."
                        if git worktree remove "$wt" --force 2>/dev/null; then
                            orphan_cleaned=$((orphan_cleaned + 1))
                        else
                            rm -rf "$wt" 2>/dev/null || true
                        fi
                    done
                    print_info "Removed orphaned worktrees"
                    ;;
                *)
                    echo "Skipped orphan cleanup"
                    ;;
            esac
        else
            print_warning "Run interactively to remove orphaned worktrees"
        fi
    else
        print_success "No orphaned worktrees found"
    fi

    echo ""
    echo "Cleanup complete. Total items cleaned: $cleaned_total"
}

cmd_cycle_layout() {
    cycle_layout
}

cmd_completion() {
    shell="${1:-bash}"
    generate_completion "$shell"
}

# Run main function with all arguments
main "$@"
