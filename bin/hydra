#!/bin/sh
# Hydra - POSIX-compliant CLI for managing parallel AI coding sessions
# Wraps tmux â‰¥ 3.0 and git worktree

set -eu

# Global variables
# Ensure HOME is set to actual user home directory
if [ -z "${HOME:-}" ] || [ ! -d "${HOME:-}" ]; then
    HOME="$(cd ~ && pwd)"
fi
HYDRA_HOME="${HYDRA_HOME:-$HOME/.hydra}"
HYDRA_MAP="$HYDRA_HOME/map"
HYDRA_VERSION="1.3.0"

# Source helper libraries
# Enhanced library detection with multiple fallback paths
# Try to resolve the real path of the hydra binary
HYDRA_BIN_PATH="$0"
if [ -L "$HYDRA_BIN_PATH" ]; then
    # Follow symlinks if possible (POSIX-compliant approach)
    if command -v readlink >/dev/null 2>&1; then
        # Try GNU readlink -f first, then BSD readlink
        HYDRA_BIN_PATH="$(readlink -f "$HYDRA_BIN_PATH" 2>/dev/null || readlink "$HYDRA_BIN_PATH" 2>/dev/null || echo "$HYDRA_BIN_PATH")"
    fi
fi

# Get the directory containing the hydra binary
if HYDRA_BIN_DIR="$(cd "$(dirname "$HYDRA_BIN_PATH")" 2>/dev/null && pwd)"; then
    : # Successfully got absolute path
else
    # Fallback to dirname if cd fails
    HYDRA_BIN_DIR="$(dirname "$HYDRA_BIN_PATH")"
fi

# Try multiple paths to find the library directory
if [ -d "$HYDRA_BIN_DIR/../lib" ] && [ -f "$HYDRA_BIN_DIR/../lib/git.sh" ]; then
    # Running from source - resolve to absolute path
    HYDRA_LIB_DIR="$(cd "$HYDRA_BIN_DIR/../lib" && pwd)"
elif [ -d "/usr/local/lib/hydra" ] && [ -f "/usr/local/lib/hydra/git.sh" ]; then
    # Installed location
    HYDRA_LIB_DIR="/usr/local/lib/hydra"
elif [ -n "${HYDRA_ROOT:-}" ] && [ -d "$HYDRA_ROOT/lib" ] && [ -f "$HYDRA_ROOT/lib/git.sh" ]; then
    # Environment variable override
    HYDRA_LIB_DIR="$HYDRA_ROOT/lib"
else
    echo "Error: Cannot find hydra library directory" >&2
    echo "Searched in:" >&2
    echo "  - $HYDRA_BIN_DIR/../lib (source)" >&2
    echo "  - /usr/local/lib/hydra (installed)" >&2
    [ -n "${HYDRA_ROOT:-}" ] && echo "  - $HYDRA_ROOT/lib (HYDRA_ROOT)" >&2
    echo "" >&2
    echo "Please ensure hydra is properly installed or set HYDRA_ROOT environment variable" >&2
    exit 1
fi

# shellcheck source=../lib/output.sh
# shellcheck disable=SC1091
. "$HYDRA_LIB_DIR/output.sh"
# shellcheck source=../lib/paths.sh
# shellcheck disable=SC1091
. "$HYDRA_LIB_DIR/paths.sh"
# shellcheck source=../lib/locks.sh
# shellcheck disable=SC1091
. "$HYDRA_LIB_DIR/locks.sh"
# shellcheck source=../lib/git.sh
# shellcheck disable=SC1091
. "$HYDRA_LIB_DIR/git.sh"
# shellcheck source=../lib/tmux.sh
# shellcheck disable=SC1091
. "$HYDRA_LIB_DIR/tmux.sh"
# shellcheck source=../lib/layout.sh
# shellcheck disable=SC1091
. "$HYDRA_LIB_DIR/layout.sh"
# shellcheck source=../lib/state.sh
# shellcheck disable=SC1091
. "$HYDRA_LIB_DIR/state.sh"
# shellcheck source=../lib/completion.sh
# shellcheck disable=SC1091
. "$HYDRA_LIB_DIR/completion.sh"
# shellcheck source=../lib/dashboard.sh
# shellcheck disable=SC1091
. "$HYDRA_LIB_DIR/dashboard.sh"
# shellcheck source=../lib/github.sh
# shellcheck disable=SC1091
. "$HYDRA_LIB_DIR/github.sh"
# shellcheck source=../lib/hooks.sh
# shellcheck disable=SC1091
. "$HYDRA_LIB_DIR/hooks.sh"
# shellcheck source=../lib/yaml.sh
# shellcheck disable=SC1091
. "$HYDRA_LIB_DIR/yaml.sh"
# shellcheck source=../lib/spawn.sh
# shellcheck disable=SC1091
. "$HYDRA_LIB_DIR/spawn.sh"
# shellcheck source=../lib/kill.sh
# shellcheck disable=SC1091
. "$HYDRA_LIB_DIR/kill.sh"
# shellcheck source=../lib/tui.sh
# shellcheck disable=SC1091
. "$HYDRA_LIB_DIR/tui.sh"

# Export paths for downstream helpers (e.g., safe tmux run-shell bindings)
export HYDRA_LIB_DIR
# Resolve the absolute path to the current hydra binary for secure bindings
HYDRA_BIN_CMD="${HYDRA_BIN_PATH}"
export HYDRA_BIN_CMD

# Initialize Hydra home directory
init_hydra_home() {
    if [ ! -d "$HYDRA_HOME" ]; then
        mkdir -p "$HYDRA_HOME"
    fi
    if [ ! -f "$HYDRA_MAP" ]; then
        touch "$HYDRA_MAP"
    fi
}

# Display usage information
usage() {
    cat <<EOF
hydra - Manage parallel AI coding sessions with tmux and git worktree

Usage: hydra <command> [options]

Commands:
  spawn <branch>    Create a new worktree and tmux session
                    Options:
                      -l, --layout <layout>    Apply tmux layout
                      -n, --count <number>     Spawn multiple sessions (1-10)
                      --ai <tool>              Specify AI tool (claude, aider, gemini, etc.)
                      --agents <spec>          Mixed agents (e.g., "claude:2,aider:1")
                      -g, --group <name>       Assign to a group for bulk operations
  spawn --issue <#> Create a head from a GitHub issue
  list              List all active Hydra heads
                    Options:
                      -g, --group <name>       Filter by group
                      --groups                 List all groups with session counts
  switch            Switch to a different head (interactive)
  kill <branch>     Remove a worktree and its tmux session
  kill --all        Kill all hydra sessions
  kill --group <n>  Kill all sessions in a group
                    Options:
                      --force          Skip confirmation prompt
  group <branch>    Show or set group for a session
                    Usage:
                      group <branch>           Show current group
                      group <branch> <name>    Set group
                      group <branch> --clear   Remove from group
  tail <branch>     View output from a session
                    Options:
                      -n, --lines <N>          Number of lines (default: 50)
                      -f, --follow             Continuously watch output
  broadcast         Send a command to multiple sessions
                    Options:
                      -g, --group <name>       Target specific group
  wait-idle         Wait for sessions to become idle
                    Options:
                      -g, --group <name>       Wait for specific group
                      -s, --seconds <N>        Idle threshold (default: 10)
                      -t, --timeout <N>        Max wait time (default: 300)
  regenerate        Restore tmux sessions for existing worktrees
  status            Show health status of all heads
  doctor            Check system performance
  dashboard         View all sessions in a single dashboard
                    Options:
                      -p, --panes-per-session <N|all>  Collect multiple panes per session
  tui               Interactive terminal UI for managing sessions
  cycle-layout      Cycle through tmux pane layouts
  completion        Generate shell completion scripts
  version           Show version information

Options:
  -h, --help        Show this help message

Examples:
  hydra spawn feature-x                    # Create single session
  hydra spawn feature-x -n 3               # Create 3 sessions (feature-x-1, feature-x-2, feature-x-3)
  hydra spawn feature-x -n 3 --ai aider    # Create 3 sessions with aider
  hydra spawn feature-x --ai gemini        # Create session with Google Gemini CLI
  hydra spawn exp --agents "claude:2,aider:1"  # Create 2 claude + 1 aider sessions
  hydra spawn --issue 42                   # Create session from GitHub issue #42
  hydra spawn feature-x -g project-a       # Create session in group 'project-a'
  hydra list --groups                      # Show all groups
  hydra list -g project-a                  # List sessions in group 'project-a'
  hydra group feature-x project-a          # Assign feature-x to group 'project-a'
  hydra tail feature-x                     # View last 50 lines of output
  hydra tail feature-x -f                  # Follow output in real-time
  hydra broadcast "git status"             # Send command to all sessions
  hydra broadcast -g project-a "make test" # Send command to group
  hydra wait-idle -g project-a             # Wait for group to finish
  hydra kill feature-x                     # Kill a specific session
  hydra kill --all                         # Kill all sessions (with confirmation)
  hydra kill --all --force                 # Kill all sessions without confirmation
  hydra kill -g project-a                  # Kill all sessions in group 'project-a'

Environment:
  HYDRA_HOME        Directory for runtime files (default: ~/.hydra)
  HYDRA_AI_COMMAND  Default AI tool (default: claude)
  HYDRA_ROOT        Override hydra installation path (for library discovery)
  HYDRA_DASHBOARD_PANES_PER_SESSION  Panes per session for dashboard (1, N, or all)
EOF
}

# Main command dispatcher
main() {
    init_hydra_home
    
    case "${1:-}" in
        spawn)
            shift
            cmd_spawn "$@"
            ;;
        list)
            shift
            cmd_list "$@"
            ;;
        switch)
            shift
            cmd_switch "$@"
            ;;
        kill)
            shift
            cmd_kill "$@"
            ;;
        group)
            shift
            cmd_group "$@"
            ;;
        tail)
            shift
            cmd_tail "$@"
            ;;
        broadcast)
            shift
            cmd_broadcast "$@"
            ;;
        wait-idle)
            shift
            cmd_wait_idle "$@"
            ;;
        regenerate)
            shift
            cmd_regenerate "$@"
            ;;
        status)
            shift
            cmd_status "$@"
            ;;
        doctor)
            shift
            cmd_doctor "$@"
            ;;
        dashboard)
            shift
            cmd_dashboard "$@"
            ;;
        dashboard-exit)
            shift
            cmd_dashboard_exit "$@"
            ;;
        tui)
            shift
            cmd_tui "$@"
            ;;
        cycle-layout)
            shift
            cmd_cycle_layout "$@"
            ;;
        completion)
            shift
            cmd_completion "$@"
            ;;
        version|-v|--version)
            echo "Hydra version $HYDRA_VERSION"
            ;;
        help|-h|--help)
            usage
            ;;
        *)
            if [ -z "${1:-}" ]; then
                usage
            else
                echo "Error: Unknown command '$1'" >&2
                echo "Run 'hydra help' for usage information" >&2
                exit 1
            fi
            ;;
    esac
}

# Command implementations
cmd_spawn() {
    # Parse arguments
    branch=""
    layout="default"
    count=1
    ai_tool=""
    agents_spec=""
    issue_num=""
    group=""

    while [ $# -gt 0 ]; do
        case "$1" in
            -l|--layout)
                shift
                layout="$1"
                shift
                ;;
            -n|--count)
                shift
                count="$1"
                shift
                ;;
            --ai)
                shift
                ai_tool="$1"
                shift
                ;;
            --agents)
                shift
                agents_spec="$1"
                shift
                ;;
            -i|--issue)
                shift
                issue_num="$1"
                shift
                ;;
            -g|--group)
                shift
                group="$1"
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: hydra spawn <branch> [-l|--layout <layout>] [-n|--count <number>] [--ai <tool>] [--agents <spec>] [-g|--group <name>]" >&2
                echo "       hydra spawn --issue <number> [-l|--layout <layout>] [-g|--group <name>]" >&2
                exit 1
                ;;
            *)
                if [ -z "$branch" ]; then
                    branch="$1"
                else
                    echo "Error: Too many arguments" >&2
                    echo "Usage: hydra spawn <branch> [-l|--layout <layout>] [-n|--count <number>] [--ai <tool>] [--agents <spec>] [-g|--group <name>]" >&2
                    echo "       hydra spawn --issue <number> [-l|--layout <layout>] [-g|--group <name>]" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done
    
    # Handle GitHub issue mode
    if [ -n "$issue_num" ]; then
        if [ -n "$branch" ]; then
            echo "Error: Cannot specify both branch name and issue number" >&2
            exit 1
        fi
        
        # Check for incompatible options
        if [ "$count" -gt 1 ] || [ -n "$agents_spec" ]; then
            echo "Error: Cannot use bulk spawn options with --issue" >&2
            exit 1
        fi
        
        # Generate branch from issue
        branch="$(spawn_from_issue "$issue_num")" || exit 1
    fi
    
    if [ -z "$branch" ]; then
        echo "Error: Branch name is required" >&2
        echo "Usage: hydra spawn <branch> [-l|--layout <layout>] [-n|--count <number>] [--ai <tool>] [--agents <spec>] [-g|--group <name>]" >&2
        echo "       hydra spawn --issue <number> [-l|--layout <layout>] [-g|--group <name>]" >&2
        exit 1
    fi
    
    # Validate count
    if ! echo "$count" | grep -q '^[0-9]\+$' || [ "$count" -lt 1 ] || [ "$count" -gt 10 ]; then
        echo "Error: Count must be a number between 1 and 10" >&2
        exit 1
    fi

    # Validate layout early to avoid injection in apply step
    case "$layout" in
        default|dev|full) ;;
        *)
            echo "Error: Invalid layout '$layout' (allowed: default, dev, full)" >&2
            exit 1
            ;;
    esac
    
    # Handle mutually exclusive options
    if [ -n "$agents_spec" ] && [ -n "$ai_tool" ]; then
        echo "Error: Cannot use both --ai and --agents options" >&2
        exit 1
    fi
    
    # If agents spec is provided, delegate to bulk spawn with mixed agents
    if [ -n "$agents_spec" ]; then
        spawn_bulk_mixed "$branch" "$agents_spec" "$layout" "$group"
        return $?
    fi

    # If count > 1, delegate to bulk spawn
    if [ "$count" -gt 1 ]; then
        spawn_bulk "$branch" "$count" "$layout" "$ai_tool" "$group"
        return $?
    fi

    # Single spawn - use helper function
    if session="$(spawn_single "$branch" "$layout" "$ai_tool" "$group")"; then
        # Optionally skip switching (useful for demos/automation)
        if [ -n "${HYDRA_NO_SWITCH:-}" ]; then
            echo "Session '$session' created (HYDRA_NO_SWITCH set; not attaching)"
        else
            # Switch to the new session (only in terminal)
            if [ -t 0 ] && [ -t 1 ]; then
                echo "Switching to session '$session'..."
                switch_to_session "$session"
            else
                echo "Session '$session' created successfully (not switching - not in terminal)"
            fi
        fi
        return 0
    else
        return 1
    fi
}

cmd_list() {
    # Parse arguments
    filter_group=""
    show_groups=""
    while [ $# -gt 0 ]; do
        case "$1" in
            -g|--group)
                shift
                filter_group="$1"
                shift
                ;;
            --groups)
                show_groups="1"
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: hydra list [-g|--group <name>] [--groups]" >&2
                exit 1
                ;;
            *)
                echo "Error: Unexpected argument '$1'" >&2
                exit 1
                ;;
        esac
    done

    # List all groups if requested
    if [ -n "$show_groups" ]; then
        groups="$(list_groups)"
        if [ -z "$groups" ]; then
            echo "No groups defined"
        else
            echo "Groups:"
            echo "$groups" | while read -r g; do
                count="$(list_mappings_for_group "$g" | wc -l | tr -d ' ')"
                echo "  $g ($count sessions)"
            done
        fi
        return 0
    fi

    # Check if we have any mappings
    if [ ! -f "$HYDRA_MAP" ] || [ ! -s "$HYDRA_MAP" ]; then
        echo "No active Hydra heads"
        return 0
    fi

    # List all sessions with their branch names
    if [ -n "$filter_group" ]; then
        echo "Active Hydra heads in group '$filter_group':"
    else
        echo "Active Hydra heads:"
    fi
    echo ""

    # Cache current session once before the loop (perf: issue #36)
    current_session="$(tmux display-message -p '#{session_name}' 2>/dev/null || true)"

    # Read mapping file and display status
    while IFS=' ' read -r branch session ai group; do
        # Filter by group if specified
        if [ -n "$filter_group" ]; then
            if [ "$group" != "$filter_group" ]; then
                continue
            fi
        fi

        # Build status line
        status_line=""
        if [ -n "$ai" ] && [ "$ai" != "-" ]; then
            status_line="[ai: $ai]"
        fi
        if [ -n "$group" ] && [ "$group" != "-" ]; then
            status_line="$status_line [group: $group]"
        fi

        # Check if session still exists
        if tmux_session_exists "$session"; then
            # Check if it's the current session
            if [ "$session" = "$current_session" ]; then
                echo "* $branch -> $session $status_line (current)"
            else
                echo "  $branch -> $session $status_line"
            fi
        else
            echo "  $branch -> $session $status_line (dead)"
        fi
    done < "$HYDRA_MAP"
}

cmd_switch() {
    # Interactive session switcher
    if [ ! -f "$HYDRA_MAP" ] || [ ! -s "$HYDRA_MAP" ]; then
        echo "No active Hydra heads to switch to"
        return 1
    fi
    
    # If inside tmux, use tmux's interactive switcher
    if [ -n "${TMUX:-}" ]; then
        # Build session list for fzf or simple menu
        sessions=""
        while IFS=' ' read -r branch session; do
            if tmux_session_exists "$session"; then
                sessions="$sessions$branch ($session)\n"
            fi
        done < "$HYDRA_MAP"
        
        if [ -z "$sessions" ]; then
            echo "No active sessions found"
            return 1
        fi
        
        # Use fzf if available, otherwise simple menu
        if command -v fzf >/dev/null 2>&1; then
            selection="$(printf "%b" "$sessions" | fzf --prompt="Switch to: " --height=10)"
        else
            echo "Active sessions:"
            i=1
            printf "%b" "$sessions" | while IFS= read -r line; do
                echo "$i) $line"
                i=$((i + 1))
            done
            printf "Select session (1-%d): " "$(printf "%b" "$sessions" | wc -l | tr -d ' ')"
            read -r choice
            selection="$(printf "%b" "$sessions" | sed -n "${choice}p")"
        fi
        
        if [ -n "$selection" ]; then
            # Extract session name from selection
            session_name="$(echo "$selection" | sed 's/.*(\(.*\))/\1/')"
            switch_to_session "$session_name"
        fi
    else
        echo "Error: Not inside a tmux session"
        echo "Use 'tmux attach -t <session>' to attach to a session"
        return 1
    fi
}

cmd_group() {
    # Assign or show group for a branch
    if [ $# -lt 1 ]; then
        echo "Error: Branch name required" >&2
        echo "Usage: hydra group <branch> [<group-name>]" >&2
        echo "       hydra group <branch> --clear" >&2
        return 1
    fi

    branch="$1"
    shift

    # Check if branch exists in mappings
    session="$(get_session_for_branch "$branch" 2>/dev/null || true)"
    if [ -z "$session" ]; then
        echo "Error: No session found for branch '$branch'" >&2
        return 1
    fi

    # If no group specified, show current group
    if [ $# -eq 0 ]; then
        current_group="$(get_group_for_branch "$branch" 2>/dev/null || true)"
        if [ -n "$current_group" ]; then
            echo "Group for '$branch': $current_group"
        else
            echo "No group assigned to '$branch'"
        fi
        return 0
    fi

    # Handle --clear
    if [ "$1" = "--clear" ]; then
        if set_group "$branch" ""; then
            echo "Cleared group for '$branch'"
        else
            echo "Error: Failed to clear group" >&2
            return 1
        fi
        return 0
    fi

    # Set the group
    new_group="$1"
    if set_group "$branch" "$new_group"; then
        echo "Set group for '$branch' to '$new_group'"
    else
        echo "Error: Failed to set group" >&2
        return 1
    fi
}

cmd_tail() {
    # Watch output from a session's pane
    lines=50
    follow=false
    branch=""

    while [ $# -gt 0 ]; do
        case "$1" in
            -n|--lines)
                shift
                lines="$1"
                shift
                ;;
            -f|--follow)
                follow=true
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: hydra tail <branch> [-n|--lines <N>] [-f|--follow]" >&2
                return 1
                ;;
            *)
                if [ -z "$branch" ]; then
                    branch="$1"
                else
                    echo "Error: Too many arguments" >&2
                    return 1
                fi
                shift
                ;;
        esac
    done

    if [ -z "$branch" ]; then
        echo "Error: Branch name required" >&2
        echo "Usage: hydra tail <branch> [-n|--lines <N>] [-f|--follow]" >&2
        return 1
    fi

    # Get session for branch
    session="$(get_session_for_branch "$branch" 2>/dev/null || true)"
    if [ -z "$session" ]; then
        echo "Error: No session found for branch '$branch'" >&2
        return 1
    fi

    if ! tmux_session_exists "$session"; then
        echo "Error: Session '$session' is not running" >&2
        return 1
    fi

    if [ "$follow" = true ]; then
        # Follow mode - continuously capture and display
        echo "Tailing session '$session' (Ctrl-C to exit)..."
        echo "---"
        trap 'echo ""; echo "---"; echo "Stopped tailing."; exit 0' INT
        last_output=""
        while true; do
            current_output="$(tmux capture-pane -t "$session" -p -S -"$lines" 2>/dev/null || true)"
            if [ "$current_output" != "$last_output" ]; then
                # Clear screen and show new output
                printf '\033[2J\033[H'
                echo "=== $branch ($session) ==="
                echo "$current_output"
            fi
            last_output="$current_output"
            sleep 1
        done
    else
        # One-shot capture
        echo "=== $branch ($session) - last $lines lines ==="
        tmux capture-pane -t "$session" -p -S -"$lines" 2>/dev/null || true
    fi
}

cmd_broadcast() {
    # Send a command to all sessions or a group
    broadcast_group=""
    command_text=""

    while [ $# -gt 0 ]; do
        case "$1" in
            -g|--group)
                shift
                broadcast_group="$1"
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: hydra broadcast [-g|--group <name>] <command>" >&2
                return 1
                ;;
            *)
                # Remaining args are the command
                command_text="$*"
                break
                ;;
        esac
    done

    if [ -z "$command_text" ]; then
        echo "Error: Command required" >&2
        echo "Usage: hydra broadcast [-g|--group <name>] <command>" >&2
        return 1
    fi

    # Get sessions to broadcast to
    if [ -n "$broadcast_group" ]; then
        mappings="$(list_mappings_for_group "$broadcast_group")"
        if [ -z "$mappings" ]; then
            echo "No sessions found in group '$broadcast_group'"
            return 1
        fi
        echo "Broadcasting to group '$broadcast_group'..."
    else
        if [ ! -f "$HYDRA_MAP" ] || [ ! -s "$HYDRA_MAP" ]; then
            echo "No active sessions"
            return 1
        fi
        mappings="$(cat "$HYDRA_MAP")"
        echo "Broadcasting to all sessions..."
    fi

    count=0
    echo "$mappings" | while IFS=' ' read -r branch session _ai _group; do
        if tmux_session_exists "$session"; then
            echo "  Sending to $branch ($session)..."
            tmux send-keys -t "$session" "$command_text" Enter 2>/dev/null || true
            count=$((count + 1))
        fi
    done

    echo "Done"
}

cmd_wait_idle() {
    # Wait for sessions to become idle (no output for N seconds)
    idle_seconds=10
    timeout_seconds=300
    wait_group=""

    while [ $# -gt 0 ]; do
        case "$1" in
            -s|--seconds)
                shift
                idle_seconds="$1"
                shift
                ;;
            -t|--timeout)
                shift
                timeout_seconds="$1"
                shift
                ;;
            -g|--group)
                shift
                wait_group="$1"
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: hydra wait-idle [-g|--group <name>] [-s|--seconds <N>] [-t|--timeout <N>]" >&2
                return 1
                ;;
            *)
                echo "Error: Unexpected argument '$1'" >&2
                return 1
                ;;
        esac
    done

    # Get sessions to monitor
    if [ -n "$wait_group" ]; then
        mappings="$(list_mappings_for_group "$wait_group")"
        if [ -z "$mappings" ]; then
            echo "No sessions found in group '$wait_group'"
            return 1
        fi
        echo "Waiting for group '$wait_group' to become idle..."
    else
        if [ ! -f "$HYDRA_MAP" ] || [ ! -s "$HYDRA_MAP" ]; then
            echo "No active sessions"
            return 0
        fi
        mappings="$(cat "$HYDRA_MAP")"
        echo "Waiting for all sessions to become idle..."
    fi

    echo "Idle threshold: ${idle_seconds}s, timeout: ${timeout_seconds}s"

    start_time="$(date +%s)"

    # Track last output hash for each session
    tmpdir="$(mktemp -d)"
    trap 'rm -rf "$tmpdir"' EXIT INT TERM

    # Initialize tracking
    echo "$mappings" | while IFS=' ' read -r branch session _ai _group; do
        if tmux_session_exists "$session"; then
            echo "$start_time" > "$tmpdir/$session.time"
            tmux capture-pane -t "$session" -p 2>/dev/null | cksum > "$tmpdir/$session.hash"
        fi
    done

    while true; do
        current_time="$(date +%s)"
        elapsed=$((current_time - start_time))

        if [ "$elapsed" -ge "$timeout_seconds" ]; then
            echo "Timeout after ${timeout_seconds}s"
            return 1
        fi

        # Use file to track idle state across subshell
        echo "idle" > "$tmpdir/status"

        echo "$mappings" | while IFS=' ' read -r _branch session _ai _group; do
            if ! tmux_session_exists "$session"; then
                continue
            fi

            # Get current output hash
            current_hash="$(tmux capture-pane -t "$session" -p 2>/dev/null | cksum)"
            last_hash="$(cat "$tmpdir/$session.hash" 2>/dev/null || echo "")"

            if [ "$current_hash" != "$last_hash" ]; then
                # Output changed, reset idle timer
                echo "$current_time" > "$tmpdir/$session.time"
                echo "$current_hash" > "$tmpdir/$session.hash"
                echo "busy" > "$tmpdir/status"
            else
                # Check if idle long enough
                last_change="$(cat "$tmpdir/$session.time" 2>/dev/null || echo "$current_time")"
                idle_time=$((current_time - last_change))
                if [ "$idle_time" -lt "$idle_seconds" ]; then
                    echo "busy" > "$tmpdir/status"
                fi
            fi
        done

        status="$(cat "$tmpdir/status")"
        if [ "$status" = "idle" ]; then
            echo ""
            echo "All sessions idle for ${idle_seconds}s"
            return 0
        fi

        printf "\r[%ds] Waiting...  " "$elapsed"
        sleep 2
    done
}

cmd_kill() {
    # Parse arguments
    branch=""
    kill_all=false
    force=false
    kill_group=""

    while [ $# -gt 0 ]; do
        case "$1" in
            --all)
                kill_all=true
                shift
                ;;
            --force)
                force=true
                shift
                ;;
            -g|--group)
                shift
                kill_group="$1"
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: hydra kill <branch>" >&2
                echo "       hydra kill --all [--force]" >&2
                echo "       hydra kill -g|--group <name> [--force]" >&2
                return 1
                ;;
            *)
                if [ -z "$branch" ]; then
                    branch="$1"
                else
                    echo "Error: Too many arguments" >&2
                    echo "Usage: hydra kill <branch>" >&2
                    echo "       hydra kill --all [--force]" >&2
                    echo "       hydra kill -g|--group <name> [--force]" >&2
                    return 1
                fi
                shift
                ;;
        esac
    done

    # Check mutual exclusivity
    if [ "$kill_all" = true ] && [ -n "$branch" ]; then
        echo "Error: Cannot specify both branch name and --all" >&2
        echo "Usage: hydra kill <branch>" >&2
        echo "       hydra kill --all [--force]" >&2
        echo "       hydra kill -g|--group <name> [--force]" >&2
        return 1
    fi

    if [ -n "$kill_group" ] && [ -n "$branch" ]; then
        echo "Error: Cannot specify both branch name and --group" >&2
        return 1
    fi

    if [ -n "$kill_group" ] && [ "$kill_all" = true ]; then
        echo "Error: Cannot specify both --all and --group" >&2
        return 1
    fi

    # If --all flag is set, delegate to kill_all_sessions
    if [ "$kill_all" = true ]; then
        kill_all_sessions "$force"
        return $?
    fi

    # If --group is set, kill all sessions in the group
    if [ -n "$kill_group" ]; then
        mappings="$(list_mappings_for_group "$kill_group")"
        if [ -z "$mappings" ]; then
            echo "No sessions found in group '$kill_group'"
            return 1
        fi

        count="$(echo "$mappings" | wc -l | tr -d ' ')"

        # Confirm unless forced
        if [ "$force" != true ] && [ -t 0 ] && [ -z "${CI:-}" ] && [ -z "${HYDRA_NONINTERACTIVE:-}" ]; then
            printf "Kill all %s sessions in group '%s'? [y/N] " "$count" "$kill_group"
            read -r response
            case "$response" in
                [yY][eE][sS]|[yY]) ;;
                *)
                    echo "Aborted"
                    return 0
                    ;;
            esac
        fi

        echo "Killing $count sessions in group '$kill_group'..."
        echo "$mappings" | while IFS=' ' read -r b _s _a _g; do
            echo "  Killing $b..."
            kill_single_head "$b" 2>/dev/null || true
        done
        echo "Done"
        return 0
    fi

    # Original single branch kill logic
    if [ -z "$branch" ]; then
        echo "Error: Branch name required" >&2
        echo "Usage: hydra kill <branch>" >&2
        echo "       hydra kill --all [--force]" >&2
        echo "       hydra kill -g|--group <name> [--force]" >&2
        return 1
    fi
    
    # Get session for branch
    session="$(get_session_for_branch "$branch" 2>/dev/null || true)"
    
    if [ -z "$session" ]; then
        echo "No session found for branch '$branch'"
        return 1
    fi
    
    # Skip confirmation in non-interactive environments (CI, tests)
    if [ -t 0 ] && [ -z "${CI:-}" ] && [ -z "${HYDRA_NONINTERACTIVE:-}" ]; then
        # Interactive mode - ask for confirmation
        printf "Kill hydra head '%s' (session: %s)? [y/N] " "$branch" "$session"
        read -r response
        case "$response" in
            [yY][eE][sS]|[yY])
                ;;
            *)
                echo "Aborted"
                return 0
                ;;
        esac
    else
        # Non-interactive mode - proceed without confirmation
        echo "Killing hydra head '$branch' (session: $session) [non-interactive mode]"
    fi
    
    # Use kill_single_head helper for the actual kill
    if kill_single_head "$branch" "$session"; then
        echo "Hydra head '$branch' has been killed"
    else
        echo "Failed to kill hydra head '$branch'" >&2
        return 1
    fi
}

cmd_regenerate() {
    echo "Regenerating tmux sessions for existing worktrees..."
    
    # Best-effort cleanup of stale session-name locks
    cleanup_stale_locks 2>/dev/null || true

    # Get repository root
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "Error: Not in a git repository" >&2
        return 1
    fi
    
    repo_root="$(git rev-parse --show-toplevel)"
    parent_dir="$(dirname "$repo_root")"
    
    # Find all hydra worktrees
    regenerated=0
    skipped=0
    
    for dir in "$parent_dir"/hydra-*; do
        if [ ! -d "$dir" ]; then
            continue
        fi
        
        # Extract branch name from directory
        branch="$(basename "$dir" | sed 's/^hydra-//')"
        
        # Check if session already exists
        existing_session="$(get_session_for_branch "$branch" 2>/dev/null || true)"
        if [ -n "$existing_session" ] && tmux_session_exists "$existing_session"; then
            echo "Session already exists for '$branch', skipping..."
            skipped=$((skipped + 1))
            continue
        fi
        
        # Generate session name
        session="$(generate_session_name "$branch")"
        
        # Create session
        echo "Creating session '$session' for branch '$branch'..."
        if create_session "$session" "$dir"; then
            # Preserve any stored AI tool for this branch
            stored_ai="$(get_ai_for_branch "$branch" 2>/dev/null || true)"
            add_mapping "$branch" "$session" "$stored_ai"
            regenerated=$((regenerated + 1))
            # Release any reserved session name lock
            release_session_lock "$session" 2>/dev/null || true
            # Apply YAML config if available; else apply custom/built-in default
            repo_root_for_dir="$(git -C "$dir" rev-parse --show-toplevel 2>/dev/null || dirname "$dir")"
            if [ -z "${HYDRA_DISABLE_YAML:-}" ] && cfgpath="$(locate_yaml_config "$dir" "$repo_root_for_dir" 2>/dev/null || true)" && [ -n "$cfgpath" ]; then
                apply_yaml_config "$cfgpath" "$session" "$dir" "$repo_root_for_dir"
            else
                apply_custom_layout_or_default "default" "$session" "$dir" "$repo_root_for_dir"
                # Optionally run startup commands on regenerate only if explicitly enabled
                if [ -n "${HYDRA_REGENERATE_RUN_STARTUP:-}" ]; then
                    run_startup_commands "$session" "$dir" "$repo_root_for_dir"
                fi
            fi
            # Optionally auto-launch stored AI tool in the regenerated session
            if [ -n "$stored_ai" ]; then
                if validate_ai_command "$stored_ai"; then
                    echo "Starting $stored_ai in session '$session'..." >&2
                    send_keys_to_session "$session" "$stored_ai"
                else
                    echo "Warning: Stored AI tool '$stored_ai' is invalid; skipping launch" >&2
                fi
            fi
        else
            echo "Failed to create session for '$branch'" >&2
            # Release any reserved session name lock
            release_session_lock "$session" 2>/dev/null || true
        fi
    done
    
    echo ""
    echo "Regeneration complete:"
    echo "  Created: $regenerated"
    echo "  Skipped: $skipped"
}

cmd_status() {
    echo "Hydra Status Report"
    echo "=================="
    echo ""
    
    # System info
    echo "System Information:"
    echo "  Hydra Version: $HYDRA_VERSION"
    echo "  tmux Version: $(tmux -V 2>/dev/null || echo "Not installed")"
    echo "  Git Version: $(git --version 2>/dev/null || echo "Not installed")"
    echo ""
    
    # Repository info
    if git rev-parse --git-dir >/dev/null 2>&1; then
        repo_root="$(git rev-parse --show-toplevel)"
        echo "Repository:"
        echo "  Path: $repo_root"
        echo "  Current Branch: $(git branch --show-current 2>/dev/null || echo "Unknown")"
        echo ""
    fi
    
    # Session info
    if [ ! -f "$HYDRA_MAP" ] || [ ! -s "$HYDRA_MAP" ]; then
        echo "No active Hydra heads"
        return 0
    fi
    
    echo "Active Heads:"
    active=0
    dead=0
    
    while IFS=' ' read -r branch session ai; do
        if tmux_session_exists "$session"; then
            if [ -n "$ai" ]; then
                echo "  [OK] $branch -> $session [ai: $ai]"
            else
                echo "  [OK] $branch -> $session"
            fi
            active=$((active + 1))
        else
            if [ -n "$ai" ]; then
                echo "  [DEAD] $branch -> $session [ai: $ai]"
            else
                echo "  [DEAD] $branch -> $session"
            fi
            dead=$((dead + 1))
        fi
    done < "$HYDRA_MAP"
    
    echo ""
    echo "Summary:"
    echo "  Active Sessions: $active"
    echo "  Dead Sessions: $dead"
    
    if [ "$dead" -gt 0 ]; then
        echo ""
        echo "Note: Dead sessions can be regenerated with 'hydra regenerate'"
    fi
}

cmd_doctor() {
    echo "Hydra Doctor - System Health Check"
    echo "================================="
    echo ""
    
    # Check dependencies
    echo "Checking dependencies..."
    errors=0
    
    # Check tmux
    if command -v tmux >/dev/null 2>&1; then
        if check_tmux_version; then
            echo "  [OK] tmux $(tmux -V)"
        else
            echo "  [FAIL] tmux version too old (need 3.0+)"
            errors=$((errors + 1))
        fi
    else
        echo "  [FAIL] tmux not installed"
        errors=$((errors + 1))
    fi
    
    # Check git
    if command -v git >/dev/null 2>&1; then
        echo "  [OK] $(git --version)"
    else
        echo "  [FAIL] git not installed"
        errors=$((errors + 1))
    fi
    
    # Check performance
    echo ""
    echo "Running performance tests..."
    
    # Test command dispatch
    start_time=$(date +%s%N 2>/dev/null || date +%s)
    "$0" version >/dev/null 2>&1
    end_time=$(date +%s%N 2>/dev/null || date +%s)
    
    if [ ${#start_time} -gt 10 ]; then
        # Nanosecond precision available
        elapsed=$(( (end_time - start_time) / 1000000 ))
        echo "  Command dispatch: ${elapsed}ms"
    else
        # Only second precision
        echo "  Command dispatch: <1000ms (no precise timing available)"
    fi
    
    # Check state file
    echo ""
    echo "Checking state management..."
    if [ -f "$HYDRA_MAP" ]; then
        echo "  [OK] State file exists: $HYDRA_MAP"
        echo "    Size: $(wc -c < "$HYDRA_MAP") bytes"
        echo "    Entries: $(wc -l < "$HYDRA_MAP" | tr -d ' ')"
    else
        echo "  [INFO] No state file (this is normal for new installations)"
    fi
    
    # Summary
    echo ""
    if [ "$errors" -eq 0 ]; then
        echo "[OK] All checks passed! Hydra is ready to use."
    else
        echo "[FAIL] Found $errors issue(s). Please install missing dependencies."
        return 1
    fi
}

cmd_cycle_layout() {
    cycle_layout
}

cmd_completion() {
    shell="${1:-bash}"
    generate_completion "$shell"
}

# Run main function with all arguments
main "$@"
